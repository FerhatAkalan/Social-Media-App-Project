{"ast":null,"code":"/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactDOMTextComponent\n * @typechecks static-only\n */\n\n'use strict';\n\nvar DOMChildrenOperations = require('./DOMChildrenOperations');\nvar DOMPropertyOperations = require('./DOMPropertyOperations');\nvar ReactComponentBrowserEnvironment = require('./ReactComponentBrowserEnvironment');\nvar ReactMount = require('./ReactMount');\nvar assign = require('./Object.assign');\nvar escapeTextContentForBrowser = require('./escapeTextContentForBrowser');\nvar setTextContent = require('./setTextContent');\nvar validateDOMNesting = require('./validateDOMNesting');\n\n/**\n * Text nodes violate a couple assumptions that React makes about components:\n *\n *  - When mounting text into the DOM, adjacent text nodes are merged.\n *  - Text nodes cannot be assigned a React root ID.\n *\n * This component is used to wrap strings in elements so that they can undergo\n * the same reconciliation that is applied to elements.\n *\n * TODO: Investigate representing React components in the DOM with text nodes.\n *\n * @class ReactDOMTextComponent\n * @extends ReactComponent\n * @internal\n */\nvar ReactDOMTextComponent = function (props) {\n  // This constructor and its argument is currently used by mocks.\n};\nassign(ReactDOMTextComponent.prototype, {\n  /**\n   * @param {ReactText} text\n   * @internal\n   */\n  construct: function (text) {\n    // TODO: This is really a ReactText (ReactNode), not a ReactElement\n    this._currentElement = text;\n    this._stringText = '' + text;\n\n    // Properties\n    this._rootNodeID = null;\n    this._mountIndex = 0;\n  },\n  /**\n   * Creates the markup for this text node. This node is not intended to have\n   * any features besides containing text content.\n   *\n   * @param {string} rootID DOM ID of the root node.\n   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction\n   * @return {string} Markup for this text node.\n   * @internal\n   */\n  mountComponent: function (rootID, transaction, context) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (context[validateDOMNesting.ancestorInfoContextKey]) {\n        validateDOMNesting('span', null, context[validateDOMNesting.ancestorInfoContextKey]);\n      }\n    }\n    this._rootNodeID = rootID;\n    if (transaction.useCreateElement) {\n      var ownerDocument = context[ReactMount.ownerDocumentContextKey];\n      var el = ownerDocument.createElement('span');\n      DOMPropertyOperations.setAttributeForID(el, rootID);\n      // Populate node cache\n      ReactMount.getID(el);\n      setTextContent(el, this._stringText);\n      return el;\n    } else {\n      var escapedText = escapeTextContentForBrowser(this._stringText);\n      if (transaction.renderToStaticMarkup) {\n        // Normally we'd wrap this in a `span` for the reasons stated above, but\n        // since this is a situation where React won't take over (static pages),\n        // we can simply return the text as it is.\n        return escapedText;\n      }\n      return '<span ' + DOMPropertyOperations.createMarkupForID(rootID) + '>' + escapedText + '</span>';\n    }\n  },\n  /**\n   * Updates this component by updating the text content.\n   *\n   * @param {ReactText} nextText The next text content\n   * @param {ReactReconcileTransaction} transaction\n   * @internal\n   */\n  receiveComponent: function (nextText, transaction) {\n    if (nextText !== this._currentElement) {\n      this._currentElement = nextText;\n      var nextStringText = '' + nextText;\n      if (nextStringText !== this._stringText) {\n        // TODO: Save this as pending props and use performUpdateIfNecessary\n        // and/or updateComponent to do the actual update for consistency with\n        // other component types?\n        this._stringText = nextStringText;\n        var node = ReactMount.getNode(this._rootNodeID);\n        DOMChildrenOperations.updateTextContent(node, nextStringText);\n      }\n    }\n  },\n  unmountComponent: function () {\n    ReactComponentBrowserEnvironment.unmountIDFromEnvironment(this._rootNodeID);\n  }\n});\nmodule.exports = ReactDOMTextComponent;","map":{"version":3,"names":["DOMChildrenOperations","require","DOMPropertyOperations","ReactComponentBrowserEnvironment","ReactMount","assign","escapeTextContentForBrowser","setTextContent","validateDOMNesting","ReactDOMTextComponent","props","prototype","construct","text","_currentElement","_stringText","_rootNodeID","_mountIndex","mountComponent","rootID","transaction","context","process","env","NODE_ENV","ancestorInfoContextKey","useCreateElement","ownerDocument","ownerDocumentContextKey","el","createElement","setAttributeForID","getID","escapedText","renderToStaticMarkup","createMarkupForID","receiveComponent","nextText","nextStringText","node","getNode","updateTextContent","unmountComponent","unmountIDFromEnvironment","module","exports"],"sources":["C:/Users/Ferhat/ws-project/wsfrontend/node_modules/react-emoji-picker/node_modules/react/lib/ReactDOMTextComponent.js"],"sourcesContent":["/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactDOMTextComponent\n * @typechecks static-only\n */\n\n'use strict';\n\nvar DOMChildrenOperations = require('./DOMChildrenOperations');\nvar DOMPropertyOperations = require('./DOMPropertyOperations');\nvar ReactComponentBrowserEnvironment = require('./ReactComponentBrowserEnvironment');\nvar ReactMount = require('./ReactMount');\n\nvar assign = require('./Object.assign');\nvar escapeTextContentForBrowser = require('./escapeTextContentForBrowser');\nvar setTextContent = require('./setTextContent');\nvar validateDOMNesting = require('./validateDOMNesting');\n\n/**\n * Text nodes violate a couple assumptions that React makes about components:\n *\n *  - When mounting text into the DOM, adjacent text nodes are merged.\n *  - Text nodes cannot be assigned a React root ID.\n *\n * This component is used to wrap strings in elements so that they can undergo\n * the same reconciliation that is applied to elements.\n *\n * TODO: Investigate representing React components in the DOM with text nodes.\n *\n * @class ReactDOMTextComponent\n * @extends ReactComponent\n * @internal\n */\nvar ReactDOMTextComponent = function (props) {\n  // This constructor and its argument is currently used by mocks.\n};\n\nassign(ReactDOMTextComponent.prototype, {\n\n  /**\n   * @param {ReactText} text\n   * @internal\n   */\n  construct: function (text) {\n    // TODO: This is really a ReactText (ReactNode), not a ReactElement\n    this._currentElement = text;\n    this._stringText = '' + text;\n\n    // Properties\n    this._rootNodeID = null;\n    this._mountIndex = 0;\n  },\n\n  /**\n   * Creates the markup for this text node. This node is not intended to have\n   * any features besides containing text content.\n   *\n   * @param {string} rootID DOM ID of the root node.\n   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction\n   * @return {string} Markup for this text node.\n   * @internal\n   */\n  mountComponent: function (rootID, transaction, context) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (context[validateDOMNesting.ancestorInfoContextKey]) {\n        validateDOMNesting('span', null, context[validateDOMNesting.ancestorInfoContextKey]);\n      }\n    }\n\n    this._rootNodeID = rootID;\n    if (transaction.useCreateElement) {\n      var ownerDocument = context[ReactMount.ownerDocumentContextKey];\n      var el = ownerDocument.createElement('span');\n      DOMPropertyOperations.setAttributeForID(el, rootID);\n      // Populate node cache\n      ReactMount.getID(el);\n      setTextContent(el, this._stringText);\n      return el;\n    } else {\n      var escapedText = escapeTextContentForBrowser(this._stringText);\n\n      if (transaction.renderToStaticMarkup) {\n        // Normally we'd wrap this in a `span` for the reasons stated above, but\n        // since this is a situation where React won't take over (static pages),\n        // we can simply return the text as it is.\n        return escapedText;\n      }\n\n      return '<span ' + DOMPropertyOperations.createMarkupForID(rootID) + '>' + escapedText + '</span>';\n    }\n  },\n\n  /**\n   * Updates this component by updating the text content.\n   *\n   * @param {ReactText} nextText The next text content\n   * @param {ReactReconcileTransaction} transaction\n   * @internal\n   */\n  receiveComponent: function (nextText, transaction) {\n    if (nextText !== this._currentElement) {\n      this._currentElement = nextText;\n      var nextStringText = '' + nextText;\n      if (nextStringText !== this._stringText) {\n        // TODO: Save this as pending props and use performUpdateIfNecessary\n        // and/or updateComponent to do the actual update for consistency with\n        // other component types?\n        this._stringText = nextStringText;\n        var node = ReactMount.getNode(this._rootNodeID);\n        DOMChildrenOperations.updateTextContent(node, nextStringText);\n      }\n    }\n  },\n\n  unmountComponent: function () {\n    ReactComponentBrowserEnvironment.unmountIDFromEnvironment(this._rootNodeID);\n  }\n\n});\n\nmodule.exports = ReactDOMTextComponent;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}