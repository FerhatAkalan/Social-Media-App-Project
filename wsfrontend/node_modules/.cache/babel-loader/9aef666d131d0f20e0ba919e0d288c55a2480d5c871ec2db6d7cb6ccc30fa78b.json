{"ast":null,"code":"import { EndOfStreamError } from './EndOfFileStream.js';\nimport { Deferred } from './Deferred.js';\nexport { EndOfStreamError } from './EndOfFileStream.js';\nconst maxStreamReadSize = 1 * 1024 * 1024; // Maximum request length on read-stream operation\nexport class StreamReader {\n  constructor(s) {\n    this.s = s;\n    /**\n     * Deferred used for postponed read request (as not data is yet available to read)\n     */\n    this.deferred = null;\n    this.endOfStream = false;\n    /**\n     * Store peeked data\n     * @type {Array}\n     */\n    this.peekQueue = [];\n    if (!s.read || !s.once) {\n      throw new Error('Expected an instance of stream.Readable');\n    }\n    this.s.once('end', () => this.reject(new EndOfStreamError()));\n    this.s.once('error', err => this.reject(err));\n    this.s.once('close', () => this.reject(new Error('Stream closed')));\n  }\n  /**\n   * Read ahead (peek) from stream. Subsequent read or peeks will return the same data\n   * @param uint8Array - Uint8Array (or Buffer) to store data read from stream in\n   * @param offset - Offset target\n   * @param length - Number of bytes to read\n   * @returns Number of bytes peeked\n   */\n  async peek(uint8Array, offset, length) {\n    const bytesRead = await this.read(uint8Array, offset, length);\n    this.peekQueue.push(uint8Array.subarray(offset, offset + bytesRead)); // Put read data back to peek buffer\n    return bytesRead;\n  }\n  /**\n   * Read chunk from stream\n   * @param buffer - Target Uint8Array (or Buffer) to store data read from stream in\n   * @param offset - Offset target\n   * @param length - Number of bytes to read\n   * @returns Number of bytes read\n   */\n  async read(buffer, offset, length) {\n    if (length === 0) {\n      return 0;\n    }\n    if (this.peekQueue.length === 0 && this.endOfStream) {\n      throw new EndOfStreamError();\n    }\n    let remaining = length;\n    let bytesRead = 0;\n    // consume peeked data first\n    while (this.peekQueue.length > 0 && remaining > 0) {\n      const peekData = this.peekQueue.pop(); // Front of queue\n      if (!peekData) throw new Error('peekData should be defined');\n      const lenCopy = Math.min(peekData.length, remaining);\n      buffer.set(peekData.subarray(0, lenCopy), offset + bytesRead);\n      bytesRead += lenCopy;\n      remaining -= lenCopy;\n      if (lenCopy < peekData.length) {\n        // remainder back to queue\n        this.peekQueue.push(peekData.subarray(lenCopy));\n      }\n    }\n    // continue reading from stream if required\n    while (remaining > 0 && !this.endOfStream) {\n      const reqLen = Math.min(remaining, maxStreamReadSize);\n      const chunkLen = await this.readFromStream(buffer, offset + bytesRead, reqLen);\n      bytesRead += chunkLen;\n      if (chunkLen < reqLen) break;\n      remaining -= chunkLen;\n    }\n    return bytesRead;\n  }\n  /**\n   * Read chunk from stream\n   * @param buffer Target Uint8Array (or Buffer) to store data read from stream in\n   * @param offset Offset target\n   * @param length Number of bytes to read\n   * @returns Number of bytes read\n   */\n  async readFromStream(buffer, offset, length) {\n    const readBuffer = this.s.read(length);\n    if (readBuffer) {\n      buffer.set(readBuffer, offset);\n      return readBuffer.length;\n    } else {\n      const request = {\n        buffer,\n        offset,\n        length,\n        deferred: new Deferred()\n      };\n      this.deferred = request.deferred;\n      this.s.once('readable', () => {\n        this.readDeferred(request);\n      });\n      return request.deferred.promise;\n    }\n  }\n  /**\n   * Process deferred read request\n   * @param request Deferred read request\n   */\n  readDeferred(request) {\n    const readBuffer = this.s.read(request.length);\n    if (readBuffer) {\n      request.buffer.set(readBuffer, request.offset);\n      request.deferred.resolve(readBuffer.length);\n      this.deferred = null;\n    } else {\n      this.s.once('readable', () => {\n        this.readDeferred(request);\n      });\n    }\n  }\n  reject(err) {\n    this.endOfStream = true;\n    if (this.deferred) {\n      this.deferred.reject(err);\n      this.deferred = null;\n    }\n  }\n}","map":{"version":3,"names":["EndOfStreamError","Deferred","maxStreamReadSize","StreamReader","constructor","s","deferred","endOfStream","peekQueue","read","once","Error","reject","err","peek","uint8Array","offset","length","bytesRead","push","subarray","buffer","remaining","peekData","pop","lenCopy","Math","min","set","reqLen","chunkLen","readFromStream","readBuffer","request","readDeferred","promise","resolve"],"sources":["C:/Users/Ferhat/Social-Media-App-Project/wsfrontend/node_modules/peek-readable/lib/StreamReader.js"],"sourcesContent":["import { EndOfStreamError } from './EndOfFileStream.js';\nimport { Deferred } from './Deferred.js';\nexport { EndOfStreamError } from './EndOfFileStream.js';\nconst maxStreamReadSize = 1 * 1024 * 1024; // Maximum request length on read-stream operation\nexport class StreamReader {\n    constructor(s) {\n        this.s = s;\n        /**\n         * Deferred used for postponed read request (as not data is yet available to read)\n         */\n        this.deferred = null;\n        this.endOfStream = false;\n        /**\n         * Store peeked data\n         * @type {Array}\n         */\n        this.peekQueue = [];\n        if (!s.read || !s.once) {\n            throw new Error('Expected an instance of stream.Readable');\n        }\n        this.s.once('end', () => this.reject(new EndOfStreamError()));\n        this.s.once('error', err => this.reject(err));\n        this.s.once('close', () => this.reject(new Error('Stream closed')));\n    }\n    /**\n     * Read ahead (peek) from stream. Subsequent read or peeks will return the same data\n     * @param uint8Array - Uint8Array (or Buffer) to store data read from stream in\n     * @param offset - Offset target\n     * @param length - Number of bytes to read\n     * @returns Number of bytes peeked\n     */\n    async peek(uint8Array, offset, length) {\n        const bytesRead = await this.read(uint8Array, offset, length);\n        this.peekQueue.push(uint8Array.subarray(offset, offset + bytesRead)); // Put read data back to peek buffer\n        return bytesRead;\n    }\n    /**\n     * Read chunk from stream\n     * @param buffer - Target Uint8Array (or Buffer) to store data read from stream in\n     * @param offset - Offset target\n     * @param length - Number of bytes to read\n     * @returns Number of bytes read\n     */\n    async read(buffer, offset, length) {\n        if (length === 0) {\n            return 0;\n        }\n        if (this.peekQueue.length === 0 && this.endOfStream) {\n            throw new EndOfStreamError();\n        }\n        let remaining = length;\n        let bytesRead = 0;\n        // consume peeked data first\n        while (this.peekQueue.length > 0 && remaining > 0) {\n            const peekData = this.peekQueue.pop(); // Front of queue\n            if (!peekData)\n                throw new Error('peekData should be defined');\n            const lenCopy = Math.min(peekData.length, remaining);\n            buffer.set(peekData.subarray(0, lenCopy), offset + bytesRead);\n            bytesRead += lenCopy;\n            remaining -= lenCopy;\n            if (lenCopy < peekData.length) {\n                // remainder back to queue\n                this.peekQueue.push(peekData.subarray(lenCopy));\n            }\n        }\n        // continue reading from stream if required\n        while (remaining > 0 && !this.endOfStream) {\n            const reqLen = Math.min(remaining, maxStreamReadSize);\n            const chunkLen = await this.readFromStream(buffer, offset + bytesRead, reqLen);\n            bytesRead += chunkLen;\n            if (chunkLen < reqLen)\n                break;\n            remaining -= chunkLen;\n        }\n        return bytesRead;\n    }\n    /**\n     * Read chunk from stream\n     * @param buffer Target Uint8Array (or Buffer) to store data read from stream in\n     * @param offset Offset target\n     * @param length Number of bytes to read\n     * @returns Number of bytes read\n     */\n    async readFromStream(buffer, offset, length) {\n        const readBuffer = this.s.read(length);\n        if (readBuffer) {\n            buffer.set(readBuffer, offset);\n            return readBuffer.length;\n        }\n        else {\n            const request = {\n                buffer,\n                offset,\n                length,\n                deferred: new Deferred()\n            };\n            this.deferred = request.deferred;\n            this.s.once('readable', () => {\n                this.readDeferred(request);\n            });\n            return request.deferred.promise;\n        }\n    }\n    /**\n     * Process deferred read request\n     * @param request Deferred read request\n     */\n    readDeferred(request) {\n        const readBuffer = this.s.read(request.length);\n        if (readBuffer) {\n            request.buffer.set(readBuffer, request.offset);\n            request.deferred.resolve(readBuffer.length);\n            this.deferred = null;\n        }\n        else {\n            this.s.once('readable', () => {\n                this.readDeferred(request);\n            });\n        }\n    }\n    reject(err) {\n        this.endOfStream = true;\n        if (this.deferred) {\n            this.deferred.reject(err);\n            this.deferred = null;\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}