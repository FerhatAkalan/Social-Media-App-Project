{"ast":null,"code":"/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule EventPropagators\n */\n\n'use strict';\n\nvar EventConstants = require('./EventConstants');\nvar EventPluginHub = require('./EventPluginHub');\nvar warning = require('fbjs/lib/warning');\nvar accumulateInto = require('./accumulateInto');\nvar forEachAccumulated = require('./forEachAccumulated');\nvar PropagationPhases = EventConstants.PropagationPhases;\nvar getListener = EventPluginHub.getListener;\n\n/**\n * Some event types have a notion of different registration names for different\n * \"phases\" of propagation. This finds listeners by a given phase.\n */\nfunction listenerAtPhase(id, event, propagationPhase) {\n  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];\n  return getListener(id, registrationName);\n}\n\n/**\n * Tags a `SyntheticEvent` with dispatched listeners. Creating this function\n * here, allows us to not have to bind or create functions for each event.\n * Mutating the event's members allows us to not have to create a wrapping\n * \"dispatch\" object that pairs the event with the listener.\n */\nfunction accumulateDirectionalDispatches(domID, upwards, event) {\n  if (process.env.NODE_ENV !== 'production') {\n    process.env.NODE_ENV !== 'production' ? warning(domID, 'Dispatching id must not be null') : undefined;\n  }\n  var phase = upwards ? PropagationPhases.bubbled : PropagationPhases.captured;\n  var listener = listenerAtPhase(domID, event, phase);\n  if (listener) {\n    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n    event._dispatchIDs = accumulateInto(event._dispatchIDs, domID);\n  }\n}\n\n/**\n * Collect dispatches (must be entirely collected before dispatching - see unit\n * tests). Lazily allocate the array to conserve memory.  We must loop through\n * each event and perform the traversal for each one. We cannot perform a\n * single traversal for the entire collection of events because each event may\n * have a different target.\n */\nfunction accumulateTwoPhaseDispatchesSingle(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    EventPluginHub.injection.getInstanceHandle().traverseTwoPhase(event.dispatchMarker, accumulateDirectionalDispatches, event);\n  }\n}\n\n/**\n * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.\n */\nfunction accumulateTwoPhaseDispatchesSingleSkipTarget(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    EventPluginHub.injection.getInstanceHandle().traverseTwoPhaseSkipTarget(event.dispatchMarker, accumulateDirectionalDispatches, event);\n  }\n}\n\n/**\n * Accumulates without regard to direction, does not look for phased\n * registration names. Same as `accumulateDirectDispatchesSingle` but without\n * requiring that the `dispatchMarker` be the same as the dispatched ID.\n */\nfunction accumulateDispatches(id, ignoredDirection, event) {\n  if (event && event.dispatchConfig.registrationName) {\n    var registrationName = event.dispatchConfig.registrationName;\n    var listener = getListener(id, registrationName);\n    if (listener) {\n      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n      event._dispatchIDs = accumulateInto(event._dispatchIDs, id);\n    }\n  }\n}\n\n/**\n * Accumulates dispatches on an `SyntheticEvent`, but only for the\n * `dispatchMarker`.\n * @param {SyntheticEvent} event\n */\nfunction accumulateDirectDispatchesSingle(event) {\n  if (event && event.dispatchConfig.registrationName) {\n    accumulateDispatches(event.dispatchMarker, null, event);\n  }\n}\nfunction accumulateTwoPhaseDispatches(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);\n}\nfunction accumulateTwoPhaseDispatchesSkipTarget(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);\n}\nfunction accumulateEnterLeaveDispatches(leave, enter, fromID, toID) {\n  EventPluginHub.injection.getInstanceHandle().traverseEnterLeave(fromID, toID, accumulateDispatches, leave, enter);\n}\nfunction accumulateDirectDispatches(events) {\n  forEachAccumulated(events, accumulateDirectDispatchesSingle);\n}\n\n/**\n * A small set of propagation patterns, each of which will accept a small amount\n * of information, and generate a set of \"dispatch ready event objects\" - which\n * are sets of events that have already been annotated with a set of dispatched\n * listener functions/ids. The API is designed this way to discourage these\n * propagation strategies from actually executing the dispatches, since we\n * always want to collect the entire set of dispatches before executing event a\n * single one.\n *\n * @constructor EventPropagators\n */\nvar EventPropagators = {\n  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,\n  accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,\n  accumulateDirectDispatches: accumulateDirectDispatches,\n  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches\n};\nmodule.exports = EventPropagators;","map":{"version":3,"names":["EventConstants","require","EventPluginHub","warning","accumulateInto","forEachAccumulated","PropagationPhases","getListener","listenerAtPhase","id","event","propagationPhase","registrationName","dispatchConfig","phasedRegistrationNames","accumulateDirectionalDispatches","domID","upwards","process","env","NODE_ENV","undefined","phase","bubbled","captured","listener","_dispatchListeners","_dispatchIDs","accumulateTwoPhaseDispatchesSingle","injection","getInstanceHandle","traverseTwoPhase","dispatchMarker","accumulateTwoPhaseDispatchesSingleSkipTarget","traverseTwoPhaseSkipTarget","accumulateDispatches","ignoredDirection","accumulateDirectDispatchesSingle","accumulateTwoPhaseDispatches","events","accumulateTwoPhaseDispatchesSkipTarget","accumulateEnterLeaveDispatches","leave","enter","fromID","toID","traverseEnterLeave","accumulateDirectDispatches","EventPropagators","module","exports"],"sources":["C:/Users/Ferhat/ws-project/wsfrontend/node_modules/react-emoji-picker/node_modules/react/lib/EventPropagators.js"],"sourcesContent":["/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule EventPropagators\n */\n\n'use strict';\n\nvar EventConstants = require('./EventConstants');\nvar EventPluginHub = require('./EventPluginHub');\n\nvar warning = require('fbjs/lib/warning');\n\nvar accumulateInto = require('./accumulateInto');\nvar forEachAccumulated = require('./forEachAccumulated');\n\nvar PropagationPhases = EventConstants.PropagationPhases;\nvar getListener = EventPluginHub.getListener;\n\n/**\n * Some event types have a notion of different registration names for different\n * \"phases\" of propagation. This finds listeners by a given phase.\n */\nfunction listenerAtPhase(id, event, propagationPhase) {\n  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];\n  return getListener(id, registrationName);\n}\n\n/**\n * Tags a `SyntheticEvent` with dispatched listeners. Creating this function\n * here, allows us to not have to bind or create functions for each event.\n * Mutating the event's members allows us to not have to create a wrapping\n * \"dispatch\" object that pairs the event with the listener.\n */\nfunction accumulateDirectionalDispatches(domID, upwards, event) {\n  if (process.env.NODE_ENV !== 'production') {\n    process.env.NODE_ENV !== 'production' ? warning(domID, 'Dispatching id must not be null') : undefined;\n  }\n  var phase = upwards ? PropagationPhases.bubbled : PropagationPhases.captured;\n  var listener = listenerAtPhase(domID, event, phase);\n  if (listener) {\n    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n    event._dispatchIDs = accumulateInto(event._dispatchIDs, domID);\n  }\n}\n\n/**\n * Collect dispatches (must be entirely collected before dispatching - see unit\n * tests). Lazily allocate the array to conserve memory.  We must loop through\n * each event and perform the traversal for each one. We cannot perform a\n * single traversal for the entire collection of events because each event may\n * have a different target.\n */\nfunction accumulateTwoPhaseDispatchesSingle(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    EventPluginHub.injection.getInstanceHandle().traverseTwoPhase(event.dispatchMarker, accumulateDirectionalDispatches, event);\n  }\n}\n\n/**\n * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.\n */\nfunction accumulateTwoPhaseDispatchesSingleSkipTarget(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    EventPluginHub.injection.getInstanceHandle().traverseTwoPhaseSkipTarget(event.dispatchMarker, accumulateDirectionalDispatches, event);\n  }\n}\n\n/**\n * Accumulates without regard to direction, does not look for phased\n * registration names. Same as `accumulateDirectDispatchesSingle` but without\n * requiring that the `dispatchMarker` be the same as the dispatched ID.\n */\nfunction accumulateDispatches(id, ignoredDirection, event) {\n  if (event && event.dispatchConfig.registrationName) {\n    var registrationName = event.dispatchConfig.registrationName;\n    var listener = getListener(id, registrationName);\n    if (listener) {\n      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n      event._dispatchIDs = accumulateInto(event._dispatchIDs, id);\n    }\n  }\n}\n\n/**\n * Accumulates dispatches on an `SyntheticEvent`, but only for the\n * `dispatchMarker`.\n * @param {SyntheticEvent} event\n */\nfunction accumulateDirectDispatchesSingle(event) {\n  if (event && event.dispatchConfig.registrationName) {\n    accumulateDispatches(event.dispatchMarker, null, event);\n  }\n}\n\nfunction accumulateTwoPhaseDispatches(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);\n}\n\nfunction accumulateTwoPhaseDispatchesSkipTarget(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);\n}\n\nfunction accumulateEnterLeaveDispatches(leave, enter, fromID, toID) {\n  EventPluginHub.injection.getInstanceHandle().traverseEnterLeave(fromID, toID, accumulateDispatches, leave, enter);\n}\n\nfunction accumulateDirectDispatches(events) {\n  forEachAccumulated(events, accumulateDirectDispatchesSingle);\n}\n\n/**\n * A small set of propagation patterns, each of which will accept a small amount\n * of information, and generate a set of \"dispatch ready event objects\" - which\n * are sets of events that have already been annotated with a set of dispatched\n * listener functions/ids. The API is designed this way to discourage these\n * propagation strategies from actually executing the dispatches, since we\n * always want to collect the entire set of dispatches before executing event a\n * single one.\n *\n * @constructor EventPropagators\n */\nvar EventPropagators = {\n  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,\n  accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,\n  accumulateDirectDispatches: accumulateDirectDispatches,\n  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches\n};\n\nmodule.exports = EventPropagators;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}