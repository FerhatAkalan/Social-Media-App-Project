{"ast":null,"code":"/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactMount\n */\n\n'use strict';\n\nvar DOMProperty = require('./DOMProperty');\nvar ReactBrowserEventEmitter = require('./ReactBrowserEventEmitter');\nvar ReactCurrentOwner = require('./ReactCurrentOwner');\nvar ReactDOMFeatureFlags = require('./ReactDOMFeatureFlags');\nvar ReactElement = require('./ReactElement');\nvar ReactEmptyComponentRegistry = require('./ReactEmptyComponentRegistry');\nvar ReactInstanceHandles = require('./ReactInstanceHandles');\nvar ReactInstanceMap = require('./ReactInstanceMap');\nvar ReactMarkupChecksum = require('./ReactMarkupChecksum');\nvar ReactPerf = require('./ReactPerf');\nvar ReactReconciler = require('./ReactReconciler');\nvar ReactUpdateQueue = require('./ReactUpdateQueue');\nvar ReactUpdates = require('./ReactUpdates');\nvar assign = require('./Object.assign');\nvar emptyObject = require('fbjs/lib/emptyObject');\nvar containsNode = require('fbjs/lib/containsNode');\nvar instantiateReactComponent = require('./instantiateReactComponent');\nvar invariant = require('fbjs/lib/invariant');\nvar setInnerHTML = require('./setInnerHTML');\nvar shouldUpdateReactComponent = require('./shouldUpdateReactComponent');\nvar validateDOMNesting = require('./validateDOMNesting');\nvar warning = require('fbjs/lib/warning');\nvar ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;\nvar nodeCache = {};\nvar ELEMENT_NODE_TYPE = 1;\nvar DOC_NODE_TYPE = 9;\nvar DOCUMENT_FRAGMENT_NODE_TYPE = 11;\nvar ownerDocumentContextKey = '__ReactMount_ownerDocument$' + Math.random().toString(36).slice(2);\n\n/** Mapping from reactRootID to React component instance. */\nvar instancesByReactRootID = {};\n\n/** Mapping from reactRootID to `container` nodes. */\nvar containersByReactRootID = {};\nif (process.env.NODE_ENV !== 'production') {\n  /** __DEV__-only mapping from reactRootID to root elements. */\n  var rootElementsByReactRootID = {};\n}\n\n// Used to store breadth-first search state in findComponentRoot.\nvar findComponentRootReusableArray = [];\n\n/**\n * Finds the index of the first character\n * that's not common between the two given strings.\n *\n * @return {number} the index of the character where the strings diverge\n */\nfunction firstDifferenceIndex(string1, string2) {\n  var minLen = Math.min(string1.length, string2.length);\n  for (var i = 0; i < minLen; i++) {\n    if (string1.charAt(i) !== string2.charAt(i)) {\n      return i;\n    }\n  }\n  return string1.length === string2.length ? -1 : minLen;\n}\n\n/**\n * @param {DOMElement|DOMDocument} container DOM element that may contain\n * a React component\n * @return {?*} DOM element that may have the reactRoot ID, or null.\n */\nfunction getReactRootElementInContainer(container) {\n  if (!container) {\n    return null;\n  }\n  if (container.nodeType === DOC_NODE_TYPE) {\n    return container.documentElement;\n  } else {\n    return container.firstChild;\n  }\n}\n\n/**\n * @param {DOMElement} container DOM element that may contain a React component.\n * @return {?string} A \"reactRoot\" ID, if a React component is rendered.\n */\nfunction getReactRootID(container) {\n  var rootElement = getReactRootElementInContainer(container);\n  return rootElement && ReactMount.getID(rootElement);\n}\n\n/**\n * Accessing node[ATTR_NAME] or calling getAttribute(ATTR_NAME) on a form\n * element can return its control whose name or ID equals ATTR_NAME. All\n * DOM nodes support `getAttributeNode` but this can also get called on\n * other objects so just return '' if we're given something other than a\n * DOM node (such as window).\n *\n * @param {?DOMElement|DOMWindow|DOMDocument|DOMTextNode} node DOM node.\n * @return {string} ID of the supplied `domNode`.\n */\nfunction getID(node) {\n  var id = internalGetID(node);\n  if (id) {\n    if (nodeCache.hasOwnProperty(id)) {\n      var cached = nodeCache[id];\n      if (cached !== node) {\n        !!isValid(cached, id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactMount: Two valid but unequal nodes with the same `%s`: %s', ATTR_NAME, id) : invariant(false) : undefined;\n        nodeCache[id] = node;\n      }\n    } else {\n      nodeCache[id] = node;\n    }\n  }\n  return id;\n}\nfunction internalGetID(node) {\n  // If node is something like a window, document, or text node, none of\n  // which support attributes or a .getAttribute method, gracefully return\n  // the empty string, as if the attribute were missing.\n  return node && node.getAttribute && node.getAttribute(ATTR_NAME) || '';\n}\n\n/**\n * Sets the React-specific ID of the given node.\n *\n * @param {DOMElement} node The DOM node whose ID will be set.\n * @param {string} id The value of the ID attribute.\n */\nfunction setID(node, id) {\n  var oldID = internalGetID(node);\n  if (oldID !== id) {\n    delete nodeCache[oldID];\n  }\n  node.setAttribute(ATTR_NAME, id);\n  nodeCache[id] = node;\n}\n\n/**\n * Finds the node with the supplied React-generated DOM ID.\n *\n * @param {string} id A React-generated DOM ID.\n * @return {DOMElement} DOM node with the suppled `id`.\n * @internal\n */\nfunction getNode(id) {\n  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {\n    nodeCache[id] = ReactMount.findReactNodeByID(id);\n  }\n  return nodeCache[id];\n}\n\n/**\n * Finds the node with the supplied public React instance.\n *\n * @param {*} instance A public React instance.\n * @return {?DOMElement} DOM node with the suppled `id`.\n * @internal\n */\nfunction getNodeFromInstance(instance) {\n  var id = ReactInstanceMap.get(instance)._rootNodeID;\n  if (ReactEmptyComponentRegistry.isNullComponentID(id)) {\n    return null;\n  }\n  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {\n    nodeCache[id] = ReactMount.findReactNodeByID(id);\n  }\n  return nodeCache[id];\n}\n\n/**\n * A node is \"valid\" if it is contained by a currently mounted container.\n *\n * This means that the node does not have to be contained by a document in\n * order to be considered valid.\n *\n * @param {?DOMElement} node The candidate DOM node.\n * @param {string} id The expected ID of the node.\n * @return {boolean} Whether the node is contained by a mounted container.\n */\nfunction isValid(node, id) {\n  if (node) {\n    !(internalGetID(node) === id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactMount: Unexpected modification of `%s`', ATTR_NAME) : invariant(false) : undefined;\n    var container = ReactMount.findReactContainerForID(id);\n    if (container && containsNode(container, node)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Causes the cache to forget about one React-specific ID.\n *\n * @param {string} id The ID to forget.\n */\nfunction purgeID(id) {\n  delete nodeCache[id];\n}\nvar deepestNodeSoFar = null;\nfunction findDeepestCachedAncestorImpl(ancestorID) {\n  var ancestor = nodeCache[ancestorID];\n  if (ancestor && isValid(ancestor, ancestorID)) {\n    deepestNodeSoFar = ancestor;\n  } else {\n    // This node isn't populated in the cache, so presumably none of its\n    // descendants are. Break out of the loop.\n    return false;\n  }\n}\n\n/**\n * Return the deepest cached node whose ID is a prefix of `targetID`.\n */\nfunction findDeepestCachedAncestor(targetID) {\n  deepestNodeSoFar = null;\n  ReactInstanceHandles.traverseAncestors(targetID, findDeepestCachedAncestorImpl);\n  var foundNode = deepestNodeSoFar;\n  deepestNodeSoFar = null;\n  return foundNode;\n}\n\n/**\n * Mounts this component and inserts it into the DOM.\n *\n * @param {ReactComponent} componentInstance The instance to mount.\n * @param {string} rootID DOM ID of the root node.\n * @param {DOMElement} container DOM element to mount into.\n * @param {ReactReconcileTransaction} transaction\n * @param {boolean} shouldReuseMarkup If true, do not insert markup\n */\nfunction mountComponentIntoNode(componentInstance, rootID, container, transaction, shouldReuseMarkup, context) {\n  if (ReactDOMFeatureFlags.useCreateElement) {\n    context = assign({}, context);\n    if (container.nodeType === DOC_NODE_TYPE) {\n      context[ownerDocumentContextKey] = container;\n    } else {\n      context[ownerDocumentContextKey] = container.ownerDocument;\n    }\n  }\n  if (process.env.NODE_ENV !== 'production') {\n    if (context === emptyObject) {\n      context = {};\n    }\n    var tag = container.nodeName.toLowerCase();\n    context[validateDOMNesting.ancestorInfoContextKey] = validateDOMNesting.updatedAncestorInfo(null, tag, null);\n  }\n  var markup = ReactReconciler.mountComponent(componentInstance, rootID, transaction, context);\n  componentInstance._renderedComponent._topLevelWrapper = componentInstance;\n  ReactMount._mountImageIntoNode(markup, container, shouldReuseMarkup, transaction);\n}\n\n/**\n * Batched mount.\n *\n * @param {ReactComponent} componentInstance The instance to mount.\n * @param {string} rootID DOM ID of the root node.\n * @param {DOMElement} container DOM element to mount into.\n * @param {boolean} shouldReuseMarkup If true, do not insert markup\n */\nfunction batchedMountComponentIntoNode(componentInstance, rootID, container, shouldReuseMarkup, context) {\n  var transaction = ReactUpdates.ReactReconcileTransaction.getPooled( /* forceHTML */shouldReuseMarkup);\n  transaction.perform(mountComponentIntoNode, null, componentInstance, rootID, container, transaction, shouldReuseMarkup, context);\n  ReactUpdates.ReactReconcileTransaction.release(transaction);\n}\n\n/**\n * Unmounts a component and removes it from the DOM.\n *\n * @param {ReactComponent} instance React component instance.\n * @param {DOMElement} container DOM element to unmount from.\n * @final\n * @internal\n * @see {ReactMount.unmountComponentAtNode}\n */\nfunction unmountComponentFromNode(instance, container) {\n  ReactReconciler.unmountComponent(instance);\n  if (container.nodeType === DOC_NODE_TYPE) {\n    container = container.documentElement;\n  }\n\n  // http://jsperf.com/emptying-a-node\n  while (container.lastChild) {\n    container.removeChild(container.lastChild);\n  }\n}\n\n/**\n * True if the supplied DOM node has a direct React-rendered child that is\n * not a React root element. Useful for warning in `render`,\n * `unmountComponentAtNode`, etc.\n *\n * @param {?DOMElement} node The candidate DOM node.\n * @return {boolean} True if the DOM element contains a direct child that was\n * rendered by React but is not a root element.\n * @internal\n */\nfunction hasNonRootReactChild(node) {\n  var reactRootID = getReactRootID(node);\n  return reactRootID ? reactRootID !== ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID) : false;\n}\n\n/**\n * Returns the first (deepest) ancestor of a node which is rendered by this copy\n * of React.\n */\nfunction findFirstReactDOMImpl(node) {\n  // This node might be from another React instance, so we make sure not to\n  // examine the node cache here\n  for (; node && node.parentNode !== node; node = node.parentNode) {\n    if (node.nodeType !== 1) {\n      // Not a DOMElement, therefore not a React component\n      continue;\n    }\n    var nodeID = internalGetID(node);\n    if (!nodeID) {\n      continue;\n    }\n    var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(nodeID);\n\n    // If containersByReactRootID contains the container we find by crawling up\n    // the tree, we know that this instance of React rendered the node.\n    // nb. isValid's strategy (with containsNode) does not work because render\n    // trees may be nested and we don't want a false positive in that case.\n    var current = node;\n    var lastID;\n    do {\n      lastID = internalGetID(current);\n      current = current.parentNode;\n      if (current == null) {\n        // The passed-in node has been detached from the container it was\n        // originally rendered into.\n        return null;\n      }\n    } while (lastID !== reactRootID);\n    if (current === containersByReactRootID[reactRootID]) {\n      return node;\n    }\n  }\n  return null;\n}\n\n/**\n * Temporary (?) hack so that we can store all top-level pending updates on\n * composites instead of having to worry about different types of components\n * here.\n */\nvar TopLevelWrapper = function () {};\nTopLevelWrapper.prototype.isReactComponent = {};\nif (process.env.NODE_ENV !== 'production') {\n  TopLevelWrapper.displayName = 'TopLevelWrapper';\n}\nTopLevelWrapper.prototype.render = function () {\n  // this.props is actually a ReactElement\n  return this.props;\n};\n\n/**\n * Mounting is the process of initializing a React component by creating its\n * representative DOM elements and inserting them into a supplied `container`.\n * Any prior content inside `container` is destroyed in the process.\n *\n *   ReactMount.render(\n *     component,\n *     document.getElementById('container')\n *   );\n *\n *   <div id=\"container\">                   <-- Supplied `container`.\n *     <div data-reactid=\".3\">              <-- Rendered reactRoot of React\n *       // ...                                 component.\n *     </div>\n *   </div>\n *\n * Inside of `container`, the first element rendered is the \"reactRoot\".\n */\nvar ReactMount = {\n  TopLevelWrapper: TopLevelWrapper,\n  /** Exposed for debugging purposes **/\n  _instancesByReactRootID: instancesByReactRootID,\n  /**\n   * This is a hook provided to support rendering React components while\n   * ensuring that the apparent scroll position of its `container` does not\n   * change.\n   *\n   * @param {DOMElement} container The `container` being rendered into.\n   * @param {function} renderCallback This must be called once to do the render.\n   */\n  scrollMonitor: function (container, renderCallback) {\n    renderCallback();\n  },\n  /**\n   * Take a component that's already mounted into the DOM and replace its props\n   * @param {ReactComponent} prevComponent component instance already in the DOM\n   * @param {ReactElement} nextElement component instance to render\n   * @param {DOMElement} container container to render into\n   * @param {?function} callback function triggered on completion\n   */\n  _updateRootComponent: function (prevComponent, nextElement, container, callback) {\n    ReactMount.scrollMonitor(container, function () {\n      ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement);\n      if (callback) {\n        ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);\n      }\n    });\n    if (process.env.NODE_ENV !== 'production') {\n      // Record the root element in case it later gets transplanted.\n      rootElementsByReactRootID[getReactRootID(container)] = getReactRootElementInContainer(container);\n    }\n    return prevComponent;\n  },\n  /**\n   * Register a component into the instance map and starts scroll value\n   * monitoring\n   * @param {ReactComponent} nextComponent component instance to render\n   * @param {DOMElement} container container to render into\n   * @return {string} reactRoot ID prefix\n   */\n  _registerComponent: function (nextComponent, container) {\n    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '_registerComponent(...): Target container is not a DOM element.') : invariant(false) : undefined;\n    ReactBrowserEventEmitter.ensureScrollValueMonitoring();\n    var reactRootID = ReactMount.registerContainer(container);\n    instancesByReactRootID[reactRootID] = nextComponent;\n    return reactRootID;\n  },\n  /**\n   * Render a new component into the DOM.\n   * @param {ReactElement} nextElement element to render\n   * @param {DOMElement} container container to render into\n   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion\n   * @return {ReactComponent} nextComponent\n   */\n  _renderNewRootComponent: function (nextElement, container, shouldReuseMarkup, context) {\n    // Various parts of our code (such as ReactCompositeComponent's\n    // _renderValidatedComponent) assume that calls to render aren't nested;\n    // verify that that's the case.\n    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : undefined;\n    var componentInstance = instantiateReactComponent(nextElement, null);\n    var reactRootID = ReactMount._registerComponent(componentInstance, container);\n\n    // The initial render is synchronous but any updates that happen during\n    // rendering, in componentWillMount or componentDidMount, will be batched\n    // according to the current batching strategy.\n\n    ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, reactRootID, container, shouldReuseMarkup, context);\n    if (process.env.NODE_ENV !== 'production') {\n      // Record the root element in case it later gets transplanted.\n      rootElementsByReactRootID[reactRootID] = getReactRootElementInContainer(container);\n    }\n    return componentInstance;\n  },\n  /**\n   * Renders a React component into the DOM in the supplied `container`.\n   *\n   * If the React component was previously rendered into `container`, this will\n   * perform an update on it and only mutate the DOM as necessary to reflect the\n   * latest React component.\n   *\n   * @param {ReactComponent} parentComponent The conceptual parent of this render tree.\n   * @param {ReactElement} nextElement Component element to render.\n   * @param {DOMElement} container DOM element to render into.\n   * @param {?function} callback function triggered on completion\n   * @return {ReactComponent} Component instance rendered in `container`.\n   */\n  renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {\n    !(parentComponent != null && parentComponent._reactInternalInstance != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'parentComponent must be a valid React Component') : invariant(false) : undefined;\n    return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);\n  },\n  _renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {\n    !ReactElement.isValidElement(nextElement) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOM.render(): Invalid component element.%s', typeof nextElement === 'string' ? ' Instead of passing an element string, make sure to instantiate ' + 'it by passing it to React.createElement.' : typeof nextElement === 'function' ? ' Instead of passing a component class, make sure to instantiate ' + 'it by passing it to React.createElement.' :\n    // Check if it quacks like an element\n    nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : invariant(false) : undefined;\n    process.env.NODE_ENV !== 'production' ? warning(!container || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : undefined;\n    var nextWrappedElement = new ReactElement(TopLevelWrapper, null, null, null, null, null, nextElement);\n    var prevComponent = instancesByReactRootID[getReactRootID(container)];\n    if (prevComponent) {\n      var prevWrappedElement = prevComponent._currentElement;\n      var prevElement = prevWrappedElement.props;\n      if (shouldUpdateReactComponent(prevElement, nextElement)) {\n        var publicInst = prevComponent._renderedComponent.getPublicInstance();\n        var updatedCallback = callback && function () {\n          callback.call(publicInst);\n        };\n        ReactMount._updateRootComponent(prevComponent, nextWrappedElement, container, updatedCallback);\n        return publicInst;\n      } else {\n        ReactMount.unmountComponentAtNode(container);\n      }\n    }\n    var reactRootElement = getReactRootElementInContainer(container);\n    var containerHasReactMarkup = reactRootElement && !!internalGetID(reactRootElement);\n    var containerHasNonRootReactChild = hasNonRootReactChild(container);\n    if (process.env.NODE_ENV !== 'production') {\n      process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.') : undefined;\n      if (!containerHasReactMarkup || reactRootElement.nextSibling) {\n        var rootElementSibling = reactRootElement;\n        while (rootElementSibling) {\n          if (internalGetID(rootElementSibling)) {\n            process.env.NODE_ENV !== 'production' ? warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.') : undefined;\n            break;\n          }\n          rootElementSibling = rootElementSibling.nextSibling;\n        }\n      }\n    }\n    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent && !containerHasNonRootReactChild;\n    var component = ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, parentComponent != null ? parentComponent._reactInternalInstance._processChildContext(parentComponent._reactInternalInstance._context) : emptyObject)._renderedComponent.getPublicInstance();\n    if (callback) {\n      callback.call(component);\n    }\n    return component;\n  },\n  /**\n   * Renders a React component into the DOM in the supplied `container`.\n   *\n   * If the React component was previously rendered into `container`, this will\n   * perform an update on it and only mutate the DOM as necessary to reflect the\n   * latest React component.\n   *\n   * @param {ReactElement} nextElement Component element to render.\n   * @param {DOMElement} container DOM element to render into.\n   * @param {?function} callback function triggered on completion\n   * @return {ReactComponent} Component instance rendered in `container`.\n   */\n  render: function (nextElement, container, callback) {\n    return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);\n  },\n  /**\n   * Registers a container node into which React components will be rendered.\n   * This also creates the \"reactRoot\" ID that will be assigned to the element\n   * rendered within.\n   *\n   * @param {DOMElement} container DOM element to register as a container.\n   * @return {string} The \"reactRoot\" ID of elements rendered within.\n   */\n  registerContainer: function (container) {\n    var reactRootID = getReactRootID(container);\n    if (reactRootID) {\n      // If one exists, make sure it is a valid \"reactRoot\" ID.\n      reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID);\n    }\n    if (!reactRootID) {\n      // No valid \"reactRoot\" ID found, create one.\n      reactRootID = ReactInstanceHandles.createReactRootID();\n    }\n    containersByReactRootID[reactRootID] = container;\n    return reactRootID;\n  },\n  /**\n   * Unmounts and destroys the React component rendered in the `container`.\n   *\n   * @param {DOMElement} container DOM element containing a React component.\n   * @return {boolean} True if a component was found in and unmounted from\n   *                   `container`\n   */\n  unmountComponentAtNode: function (container) {\n    // Various parts of our code (such as ReactCompositeComponent's\n    // _renderValidatedComponent) assume that calls to render aren't nested;\n    // verify that that's the case. (Strictly speaking, unmounting won't cause a\n    // render but we still don't expect to be in a render call here.)\n    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from render ' + 'is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : undefined;\n    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : invariant(false) : undefined;\n    var reactRootID = getReactRootID(container);\n    var component = instancesByReactRootID[reactRootID];\n    if (!component) {\n      // Check if the node being unmounted was rendered by React, but isn't a\n      // root node.\n      var containerHasNonRootReactChild = hasNonRootReactChild(container);\n\n      // Check if the container itself is a React root node.\n      var containerID = internalGetID(container);\n      var isContainerReactRoot = containerID && containerID === ReactInstanceHandles.getReactRootIDFromNodeID(containerID);\n      if (process.env.NODE_ENV !== 'production') {\n        process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'unmountComponentAtNode(): The node you\\'re attempting to unmount ' + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.') : undefined;\n      }\n      return false;\n    }\n    ReactUpdates.batchedUpdates(unmountComponentFromNode, component, container);\n    delete instancesByReactRootID[reactRootID];\n    delete containersByReactRootID[reactRootID];\n    if (process.env.NODE_ENV !== 'production') {\n      delete rootElementsByReactRootID[reactRootID];\n    }\n    return true;\n  },\n  /**\n   * Finds the container DOM element that contains React component to which the\n   * supplied DOM `id` belongs.\n   *\n   * @param {string} id The ID of an element rendered by a React component.\n   * @return {?DOMElement} DOM element that contains the `id`.\n   */\n  findReactContainerForID: function (id) {\n    var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(id);\n    var container = containersByReactRootID[reactRootID];\n    if (process.env.NODE_ENV !== 'production') {\n      var rootElement = rootElementsByReactRootID[reactRootID];\n      if (rootElement && rootElement.parentNode !== container) {\n        process.env.NODE_ENV !== 'production' ? warning(\n        // Call internalGetID here because getID calls isValid which calls\n        // findReactContainerForID (this function).\n        internalGetID(rootElement) === reactRootID, 'ReactMount: Root element ID differed from reactRootID.') : undefined;\n        var containerChild = container.firstChild;\n        if (containerChild && reactRootID === internalGetID(containerChild)) {\n          // If the container has a new child with the same ID as the old\n          // root element, then rootElementsByReactRootID[reactRootID] is\n          // just stale and needs to be updated. The case that deserves a\n          // warning is when the container is empty.\n          rootElementsByReactRootID[reactRootID] = containerChild;\n        } else {\n          process.env.NODE_ENV !== 'production' ? warning(false, 'ReactMount: Root element has been removed from its original ' + 'container. New container: %s', rootElement.parentNode) : undefined;\n        }\n      }\n    }\n    return container;\n  },\n  /**\n   * Finds an element rendered by React with the supplied ID.\n   *\n   * @param {string} id ID of a DOM node in the React component.\n   * @return {DOMElement} Root DOM node of the React component.\n   */\n  findReactNodeByID: function (id) {\n    var reactRoot = ReactMount.findReactContainerForID(id);\n    return ReactMount.findComponentRoot(reactRoot, id);\n  },\n  /**\n   * Traverses up the ancestors of the supplied node to find a node that is a\n   * DOM representation of a React component rendered by this copy of React.\n   *\n   * @param {*} node\n   * @return {?DOMEventTarget}\n   * @internal\n   */\n  getFirstReactDOM: function (node) {\n    return findFirstReactDOMImpl(node);\n  },\n  /**\n   * Finds a node with the supplied `targetID` inside of the supplied\n   * `ancestorNode`.  Exploits the ID naming scheme to perform the search\n   * quickly.\n   *\n   * @param {DOMEventTarget} ancestorNode Search from this root.\n   * @pararm {string} targetID ID of the DOM representation of the component.\n   * @return {DOMEventTarget} DOM node with the supplied `targetID`.\n   * @internal\n   */\n  findComponentRoot: function (ancestorNode, targetID) {\n    var firstChildren = findComponentRootReusableArray;\n    var childIndex = 0;\n    var deepestAncestor = findDeepestCachedAncestor(targetID) || ancestorNode;\n    if (process.env.NODE_ENV !== 'production') {\n      // This will throw on the next line; give an early warning\n      process.env.NODE_ENV !== 'production' ? warning(deepestAncestor != null, 'React can\\'t find the root component node for data-reactid value ' + '`%s`. If you\\'re seeing this message, it probably means that ' + 'you\\'ve loaded two copies of React on the page. At this time, only ' + 'a single copy of React can be loaded at a time.', targetID) : undefined;\n    }\n    firstChildren[0] = deepestAncestor.firstChild;\n    firstChildren.length = 1;\n    while (childIndex < firstChildren.length) {\n      var child = firstChildren[childIndex++];\n      var targetChild;\n      while (child) {\n        var childID = ReactMount.getID(child);\n        if (childID) {\n          // Even if we find the node we're looking for, we finish looping\n          // through its siblings to ensure they're cached so that we don't have\n          // to revisit this node again. Otherwise, we make n^2 calls to getID\n          // when visiting the many children of a single node in order.\n\n          if (targetID === childID) {\n            targetChild = child;\n          } else if (ReactInstanceHandles.isAncestorIDOf(childID, targetID)) {\n            // If we find a child whose ID is an ancestor of the given ID,\n            // then we can be sure that we only want to search the subtree\n            // rooted at this child, so we can throw out the rest of the\n            // search state.\n            firstChildren.length = childIndex = 0;\n            firstChildren.push(child.firstChild);\n          }\n        } else {\n          // If this child had no ID, then there's a chance that it was\n          // injected automatically by the browser, as when a `<table>`\n          // element sprouts an extra `<tbody>` child as a side effect of\n          // `.innerHTML` parsing. Optimistically continue down this\n          // branch, but not before examining the other siblings.\n          firstChildren.push(child.firstChild);\n        }\n        child = child.nextSibling;\n      }\n      if (targetChild) {\n        // Emptying firstChildren/findComponentRootReusableArray is\n        // not necessary for correctness, but it helps the GC reclaim\n        // any nodes that were left at the end of the search.\n        firstChildren.length = 0;\n        return targetChild;\n      }\n    }\n    firstChildren.length = 0;\n    !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'findComponentRoot(..., %s): Unable to find element. This probably ' + 'means the DOM was unexpectedly mutated (e.g., by the browser), ' + 'usually due to forgetting a <tbody> when using tables, nesting tags ' + 'like <form>, <p>, or <a>, or using non-SVG elements in an <svg> ' + 'parent. ' + 'Try inspecting the child nodes of the element with React ID `%s`.', targetID, ReactMount.getID(ancestorNode)) : invariant(false) : undefined;\n  },\n  _mountImageIntoNode: function (markup, container, shouldReuseMarkup, transaction) {\n    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mountComponentIntoNode(...): Target container is not valid.') : invariant(false) : undefined;\n    if (shouldReuseMarkup) {\n      var rootElement = getReactRootElementInContainer(container);\n      if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {\n        return;\n      } else {\n        var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);\n        rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);\n        var rootMarkup = rootElement.outerHTML;\n        rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);\n        var normalizedMarkup = markup;\n        if (process.env.NODE_ENV !== 'production') {\n          // because rootMarkup is retrieved from the DOM, various normalizations\n          // will have occurred which will not be present in `markup`. Here,\n          // insert markup into a <div> or <iframe> depending on the container\n          // type to perform the same normalizations before comparing.\n          var normalizer;\n          if (container.nodeType === ELEMENT_NODE_TYPE) {\n            normalizer = document.createElement('div');\n            normalizer.innerHTML = markup;\n            normalizedMarkup = normalizer.innerHTML;\n          } else {\n            normalizer = document.createElement('iframe');\n            document.body.appendChild(normalizer);\n            normalizer.contentDocument.write(markup);\n            normalizedMarkup = normalizer.contentDocument.documentElement.outerHTML;\n            document.body.removeChild(normalizer);\n          }\n        }\n        var diffIndex = firstDifferenceIndex(normalizedMarkup, rootMarkup);\n        var difference = ' (client) ' + normalizedMarkup.substring(diffIndex - 20, diffIndex + 20) + '\\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);\n        !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\\'re trying to render a component to the document using ' + 'server rendering but the checksum was invalid. This usually ' + 'means you rendered a different component type or props on ' + 'the client from the one on the server, or your render() ' + 'methods are impure. React cannot handle this case due to ' + 'cross-browser quirks by rendering at the document root. You ' + 'should look for environment dependent code in your components ' + 'and ensure the props are the same client and server side:\\n%s', difference) : invariant(false) : undefined;\n        if (process.env.NODE_ENV !== 'production') {\n          process.env.NODE_ENV !== 'production' ? warning(false, 'React attempted to reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server:\\n%s', difference) : undefined;\n        }\n      }\n    }\n    !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\\'re trying to render a component to the document but ' + 'you didn\\'t use server rendering. We can\\'t do this ' + 'without using server rendering due to cross-browser quirks. ' + 'See ReactDOMServer.renderToString() for server rendering.') : invariant(false) : undefined;\n    if (transaction.useCreateElement) {\n      while (container.lastChild) {\n        container.removeChild(container.lastChild);\n      }\n      container.appendChild(markup);\n    } else {\n      setInnerHTML(container, markup);\n    }\n  },\n  ownerDocumentContextKey: ownerDocumentContextKey,\n  /**\n   * React ID utilities.\n   */\n\n  getReactRootID: getReactRootID,\n  getID: getID,\n  setID: setID,\n  getNode: getNode,\n  getNodeFromInstance: getNodeFromInstance,\n  isValid: isValid,\n  purgeID: purgeID\n};\nReactPerf.measureMethods(ReactMount, 'ReactMount', {\n  _renderNewRootComponent: '_renderNewRootComponent',\n  _mountImageIntoNode: '_mountImageIntoNode'\n});\nmodule.exports = ReactMount;","map":{"version":3,"names":["DOMProperty","require","ReactBrowserEventEmitter","ReactCurrentOwner","ReactDOMFeatureFlags","ReactElement","ReactEmptyComponentRegistry","ReactInstanceHandles","ReactInstanceMap","ReactMarkupChecksum","ReactPerf","ReactReconciler","ReactUpdateQueue","ReactUpdates","assign","emptyObject","containsNode","instantiateReactComponent","invariant","setInnerHTML","shouldUpdateReactComponent","validateDOMNesting","warning","ATTR_NAME","ID_ATTRIBUTE_NAME","nodeCache","ELEMENT_NODE_TYPE","DOC_NODE_TYPE","DOCUMENT_FRAGMENT_NODE_TYPE","ownerDocumentContextKey","Math","random","toString","slice","instancesByReactRootID","containersByReactRootID","process","env","NODE_ENV","rootElementsByReactRootID","findComponentRootReusableArray","firstDifferenceIndex","string1","string2","minLen","min","length","i","charAt","getReactRootElementInContainer","container","nodeType","documentElement","firstChild","getReactRootID","rootElement","ReactMount","getID","node","id","internalGetID","hasOwnProperty","cached","isValid","undefined","getAttribute","setID","oldID","setAttribute","getNode","findReactNodeByID","getNodeFromInstance","instance","get","_rootNodeID","isNullComponentID","findReactContainerForID","purgeID","deepestNodeSoFar","findDeepestCachedAncestorImpl","ancestorID","ancestor","findDeepestCachedAncestor","targetID","traverseAncestors","foundNode","mountComponentIntoNode","componentInstance","rootID","transaction","shouldReuseMarkup","context","useCreateElement","ownerDocument","tag","nodeName","toLowerCase","ancestorInfoContextKey","updatedAncestorInfo","markup","mountComponent","_renderedComponent","_topLevelWrapper","_mountImageIntoNode","batchedMountComponentIntoNode","ReactReconcileTransaction","getPooled","perform","release","unmountComponentFromNode","unmountComponent","lastChild","removeChild","hasNonRootReactChild","reactRootID","getReactRootIDFromNodeID","findFirstReactDOMImpl","parentNode","nodeID","current","lastID","TopLevelWrapper","prototype","isReactComponent","displayName","render","props","_instancesByReactRootID","scrollMonitor","renderCallback","_updateRootComponent","prevComponent","nextElement","callback","enqueueElementInternal","enqueueCallbackInternal","_registerComponent","nextComponent","ensureScrollValueMonitoring","registerContainer","_renderNewRootComponent","getName","batchedUpdates","renderSubtreeIntoContainer","parentComponent","_reactInternalInstance","_renderSubtreeIntoContainer","isValidElement","tagName","toUpperCase","nextWrappedElement","prevWrappedElement","_currentElement","prevElement","publicInst","getPublicInstance","updatedCallback","call","unmountComponentAtNode","reactRootElement","containerHasReactMarkup","containerHasNonRootReactChild","nextSibling","rootElementSibling","component","_processChildContext","_context","createReactRootID","containerID","isContainerReactRoot","containerChild","reactRoot","findComponentRoot","getFirstReactDOM","ancestorNode","firstChildren","childIndex","deepestAncestor","child","targetChild","childID","isAncestorIDOf","push","canReuseMarkup","checksum","CHECKSUM_ATTR_NAME","removeAttribute","rootMarkup","outerHTML","normalizedMarkup","normalizer","document","createElement","innerHTML","body","appendChild","contentDocument","write","diffIndex","difference","substring","measureMethods","module","exports"],"sources":["C:/Users/Ferhat/ws-project/wsfrontend/node_modules/react-emoji-picker/node_modules/react/lib/ReactMount.js"],"sourcesContent":["/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactMount\n */\n\n'use strict';\n\nvar DOMProperty = require('./DOMProperty');\nvar ReactBrowserEventEmitter = require('./ReactBrowserEventEmitter');\nvar ReactCurrentOwner = require('./ReactCurrentOwner');\nvar ReactDOMFeatureFlags = require('./ReactDOMFeatureFlags');\nvar ReactElement = require('./ReactElement');\nvar ReactEmptyComponentRegistry = require('./ReactEmptyComponentRegistry');\nvar ReactInstanceHandles = require('./ReactInstanceHandles');\nvar ReactInstanceMap = require('./ReactInstanceMap');\nvar ReactMarkupChecksum = require('./ReactMarkupChecksum');\nvar ReactPerf = require('./ReactPerf');\nvar ReactReconciler = require('./ReactReconciler');\nvar ReactUpdateQueue = require('./ReactUpdateQueue');\nvar ReactUpdates = require('./ReactUpdates');\n\nvar assign = require('./Object.assign');\nvar emptyObject = require('fbjs/lib/emptyObject');\nvar containsNode = require('fbjs/lib/containsNode');\nvar instantiateReactComponent = require('./instantiateReactComponent');\nvar invariant = require('fbjs/lib/invariant');\nvar setInnerHTML = require('./setInnerHTML');\nvar shouldUpdateReactComponent = require('./shouldUpdateReactComponent');\nvar validateDOMNesting = require('./validateDOMNesting');\nvar warning = require('fbjs/lib/warning');\n\nvar ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;\nvar nodeCache = {};\n\nvar ELEMENT_NODE_TYPE = 1;\nvar DOC_NODE_TYPE = 9;\nvar DOCUMENT_FRAGMENT_NODE_TYPE = 11;\n\nvar ownerDocumentContextKey = '__ReactMount_ownerDocument$' + Math.random().toString(36).slice(2);\n\n/** Mapping from reactRootID to React component instance. */\nvar instancesByReactRootID = {};\n\n/** Mapping from reactRootID to `container` nodes. */\nvar containersByReactRootID = {};\n\nif (process.env.NODE_ENV !== 'production') {\n  /** __DEV__-only mapping from reactRootID to root elements. */\n  var rootElementsByReactRootID = {};\n}\n\n// Used to store breadth-first search state in findComponentRoot.\nvar findComponentRootReusableArray = [];\n\n/**\n * Finds the index of the first character\n * that's not common between the two given strings.\n *\n * @return {number} the index of the character where the strings diverge\n */\nfunction firstDifferenceIndex(string1, string2) {\n  var minLen = Math.min(string1.length, string2.length);\n  for (var i = 0; i < minLen; i++) {\n    if (string1.charAt(i) !== string2.charAt(i)) {\n      return i;\n    }\n  }\n  return string1.length === string2.length ? -1 : minLen;\n}\n\n/**\n * @param {DOMElement|DOMDocument} container DOM element that may contain\n * a React component\n * @return {?*} DOM element that may have the reactRoot ID, or null.\n */\nfunction getReactRootElementInContainer(container) {\n  if (!container) {\n    return null;\n  }\n\n  if (container.nodeType === DOC_NODE_TYPE) {\n    return container.documentElement;\n  } else {\n    return container.firstChild;\n  }\n}\n\n/**\n * @param {DOMElement} container DOM element that may contain a React component.\n * @return {?string} A \"reactRoot\" ID, if a React component is rendered.\n */\nfunction getReactRootID(container) {\n  var rootElement = getReactRootElementInContainer(container);\n  return rootElement && ReactMount.getID(rootElement);\n}\n\n/**\n * Accessing node[ATTR_NAME] or calling getAttribute(ATTR_NAME) on a form\n * element can return its control whose name or ID equals ATTR_NAME. All\n * DOM nodes support `getAttributeNode` but this can also get called on\n * other objects so just return '' if we're given something other than a\n * DOM node (such as window).\n *\n * @param {?DOMElement|DOMWindow|DOMDocument|DOMTextNode} node DOM node.\n * @return {string} ID of the supplied `domNode`.\n */\nfunction getID(node) {\n  var id = internalGetID(node);\n  if (id) {\n    if (nodeCache.hasOwnProperty(id)) {\n      var cached = nodeCache[id];\n      if (cached !== node) {\n        !!isValid(cached, id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactMount: Two valid but unequal nodes with the same `%s`: %s', ATTR_NAME, id) : invariant(false) : undefined;\n\n        nodeCache[id] = node;\n      }\n    } else {\n      nodeCache[id] = node;\n    }\n  }\n\n  return id;\n}\n\nfunction internalGetID(node) {\n  // If node is something like a window, document, or text node, none of\n  // which support attributes or a .getAttribute method, gracefully return\n  // the empty string, as if the attribute were missing.\n  return node && node.getAttribute && node.getAttribute(ATTR_NAME) || '';\n}\n\n/**\n * Sets the React-specific ID of the given node.\n *\n * @param {DOMElement} node The DOM node whose ID will be set.\n * @param {string} id The value of the ID attribute.\n */\nfunction setID(node, id) {\n  var oldID = internalGetID(node);\n  if (oldID !== id) {\n    delete nodeCache[oldID];\n  }\n  node.setAttribute(ATTR_NAME, id);\n  nodeCache[id] = node;\n}\n\n/**\n * Finds the node with the supplied React-generated DOM ID.\n *\n * @param {string} id A React-generated DOM ID.\n * @return {DOMElement} DOM node with the suppled `id`.\n * @internal\n */\nfunction getNode(id) {\n  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {\n    nodeCache[id] = ReactMount.findReactNodeByID(id);\n  }\n  return nodeCache[id];\n}\n\n/**\n * Finds the node with the supplied public React instance.\n *\n * @param {*} instance A public React instance.\n * @return {?DOMElement} DOM node with the suppled `id`.\n * @internal\n */\nfunction getNodeFromInstance(instance) {\n  var id = ReactInstanceMap.get(instance)._rootNodeID;\n  if (ReactEmptyComponentRegistry.isNullComponentID(id)) {\n    return null;\n  }\n  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {\n    nodeCache[id] = ReactMount.findReactNodeByID(id);\n  }\n  return nodeCache[id];\n}\n\n/**\n * A node is \"valid\" if it is contained by a currently mounted container.\n *\n * This means that the node does not have to be contained by a document in\n * order to be considered valid.\n *\n * @param {?DOMElement} node The candidate DOM node.\n * @param {string} id The expected ID of the node.\n * @return {boolean} Whether the node is contained by a mounted container.\n */\nfunction isValid(node, id) {\n  if (node) {\n    !(internalGetID(node) === id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactMount: Unexpected modification of `%s`', ATTR_NAME) : invariant(false) : undefined;\n\n    var container = ReactMount.findReactContainerForID(id);\n    if (container && containsNode(container, node)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Causes the cache to forget about one React-specific ID.\n *\n * @param {string} id The ID to forget.\n */\nfunction purgeID(id) {\n  delete nodeCache[id];\n}\n\nvar deepestNodeSoFar = null;\nfunction findDeepestCachedAncestorImpl(ancestorID) {\n  var ancestor = nodeCache[ancestorID];\n  if (ancestor && isValid(ancestor, ancestorID)) {\n    deepestNodeSoFar = ancestor;\n  } else {\n    // This node isn't populated in the cache, so presumably none of its\n    // descendants are. Break out of the loop.\n    return false;\n  }\n}\n\n/**\n * Return the deepest cached node whose ID is a prefix of `targetID`.\n */\nfunction findDeepestCachedAncestor(targetID) {\n  deepestNodeSoFar = null;\n  ReactInstanceHandles.traverseAncestors(targetID, findDeepestCachedAncestorImpl);\n\n  var foundNode = deepestNodeSoFar;\n  deepestNodeSoFar = null;\n  return foundNode;\n}\n\n/**\n * Mounts this component and inserts it into the DOM.\n *\n * @param {ReactComponent} componentInstance The instance to mount.\n * @param {string} rootID DOM ID of the root node.\n * @param {DOMElement} container DOM element to mount into.\n * @param {ReactReconcileTransaction} transaction\n * @param {boolean} shouldReuseMarkup If true, do not insert markup\n */\nfunction mountComponentIntoNode(componentInstance, rootID, container, transaction, shouldReuseMarkup, context) {\n  if (ReactDOMFeatureFlags.useCreateElement) {\n    context = assign({}, context);\n    if (container.nodeType === DOC_NODE_TYPE) {\n      context[ownerDocumentContextKey] = container;\n    } else {\n      context[ownerDocumentContextKey] = container.ownerDocument;\n    }\n  }\n  if (process.env.NODE_ENV !== 'production') {\n    if (context === emptyObject) {\n      context = {};\n    }\n    var tag = container.nodeName.toLowerCase();\n    context[validateDOMNesting.ancestorInfoContextKey] = validateDOMNesting.updatedAncestorInfo(null, tag, null);\n  }\n  var markup = ReactReconciler.mountComponent(componentInstance, rootID, transaction, context);\n  componentInstance._renderedComponent._topLevelWrapper = componentInstance;\n  ReactMount._mountImageIntoNode(markup, container, shouldReuseMarkup, transaction);\n}\n\n/**\n * Batched mount.\n *\n * @param {ReactComponent} componentInstance The instance to mount.\n * @param {string} rootID DOM ID of the root node.\n * @param {DOMElement} container DOM element to mount into.\n * @param {boolean} shouldReuseMarkup If true, do not insert markup\n */\nfunction batchedMountComponentIntoNode(componentInstance, rootID, container, shouldReuseMarkup, context) {\n  var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(\n  /* forceHTML */shouldReuseMarkup);\n  transaction.perform(mountComponentIntoNode, null, componentInstance, rootID, container, transaction, shouldReuseMarkup, context);\n  ReactUpdates.ReactReconcileTransaction.release(transaction);\n}\n\n/**\n * Unmounts a component and removes it from the DOM.\n *\n * @param {ReactComponent} instance React component instance.\n * @param {DOMElement} container DOM element to unmount from.\n * @final\n * @internal\n * @see {ReactMount.unmountComponentAtNode}\n */\nfunction unmountComponentFromNode(instance, container) {\n  ReactReconciler.unmountComponent(instance);\n\n  if (container.nodeType === DOC_NODE_TYPE) {\n    container = container.documentElement;\n  }\n\n  // http://jsperf.com/emptying-a-node\n  while (container.lastChild) {\n    container.removeChild(container.lastChild);\n  }\n}\n\n/**\n * True if the supplied DOM node has a direct React-rendered child that is\n * not a React root element. Useful for warning in `render`,\n * `unmountComponentAtNode`, etc.\n *\n * @param {?DOMElement} node The candidate DOM node.\n * @return {boolean} True if the DOM element contains a direct child that was\n * rendered by React but is not a root element.\n * @internal\n */\nfunction hasNonRootReactChild(node) {\n  var reactRootID = getReactRootID(node);\n  return reactRootID ? reactRootID !== ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID) : false;\n}\n\n/**\n * Returns the first (deepest) ancestor of a node which is rendered by this copy\n * of React.\n */\nfunction findFirstReactDOMImpl(node) {\n  // This node might be from another React instance, so we make sure not to\n  // examine the node cache here\n  for (; node && node.parentNode !== node; node = node.parentNode) {\n    if (node.nodeType !== 1) {\n      // Not a DOMElement, therefore not a React component\n      continue;\n    }\n    var nodeID = internalGetID(node);\n    if (!nodeID) {\n      continue;\n    }\n    var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(nodeID);\n\n    // If containersByReactRootID contains the container we find by crawling up\n    // the tree, we know that this instance of React rendered the node.\n    // nb. isValid's strategy (with containsNode) does not work because render\n    // trees may be nested and we don't want a false positive in that case.\n    var current = node;\n    var lastID;\n    do {\n      lastID = internalGetID(current);\n      current = current.parentNode;\n      if (current == null) {\n        // The passed-in node has been detached from the container it was\n        // originally rendered into.\n        return null;\n      }\n    } while (lastID !== reactRootID);\n\n    if (current === containersByReactRootID[reactRootID]) {\n      return node;\n    }\n  }\n  return null;\n}\n\n/**\n * Temporary (?) hack so that we can store all top-level pending updates on\n * composites instead of having to worry about different types of components\n * here.\n */\nvar TopLevelWrapper = function () {};\nTopLevelWrapper.prototype.isReactComponent = {};\nif (process.env.NODE_ENV !== 'production') {\n  TopLevelWrapper.displayName = 'TopLevelWrapper';\n}\nTopLevelWrapper.prototype.render = function () {\n  // this.props is actually a ReactElement\n  return this.props;\n};\n\n/**\n * Mounting is the process of initializing a React component by creating its\n * representative DOM elements and inserting them into a supplied `container`.\n * Any prior content inside `container` is destroyed in the process.\n *\n *   ReactMount.render(\n *     component,\n *     document.getElementById('container')\n *   );\n *\n *   <div id=\"container\">                   <-- Supplied `container`.\n *     <div data-reactid=\".3\">              <-- Rendered reactRoot of React\n *       // ...                                 component.\n *     </div>\n *   </div>\n *\n * Inside of `container`, the first element rendered is the \"reactRoot\".\n */\nvar ReactMount = {\n\n  TopLevelWrapper: TopLevelWrapper,\n\n  /** Exposed for debugging purposes **/\n  _instancesByReactRootID: instancesByReactRootID,\n\n  /**\n   * This is a hook provided to support rendering React components while\n   * ensuring that the apparent scroll position of its `container` does not\n   * change.\n   *\n   * @param {DOMElement} container The `container` being rendered into.\n   * @param {function} renderCallback This must be called once to do the render.\n   */\n  scrollMonitor: function (container, renderCallback) {\n    renderCallback();\n  },\n\n  /**\n   * Take a component that's already mounted into the DOM and replace its props\n   * @param {ReactComponent} prevComponent component instance already in the DOM\n   * @param {ReactElement} nextElement component instance to render\n   * @param {DOMElement} container container to render into\n   * @param {?function} callback function triggered on completion\n   */\n  _updateRootComponent: function (prevComponent, nextElement, container, callback) {\n    ReactMount.scrollMonitor(container, function () {\n      ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement);\n      if (callback) {\n        ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);\n      }\n    });\n\n    if (process.env.NODE_ENV !== 'production') {\n      // Record the root element in case it later gets transplanted.\n      rootElementsByReactRootID[getReactRootID(container)] = getReactRootElementInContainer(container);\n    }\n\n    return prevComponent;\n  },\n\n  /**\n   * Register a component into the instance map and starts scroll value\n   * monitoring\n   * @param {ReactComponent} nextComponent component instance to render\n   * @param {DOMElement} container container to render into\n   * @return {string} reactRoot ID prefix\n   */\n  _registerComponent: function (nextComponent, container) {\n    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '_registerComponent(...): Target container is not a DOM element.') : invariant(false) : undefined;\n\n    ReactBrowserEventEmitter.ensureScrollValueMonitoring();\n\n    var reactRootID = ReactMount.registerContainer(container);\n    instancesByReactRootID[reactRootID] = nextComponent;\n    return reactRootID;\n  },\n\n  /**\n   * Render a new component into the DOM.\n   * @param {ReactElement} nextElement element to render\n   * @param {DOMElement} container container to render into\n   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion\n   * @return {ReactComponent} nextComponent\n   */\n  _renderNewRootComponent: function (nextElement, container, shouldReuseMarkup, context) {\n    // Various parts of our code (such as ReactCompositeComponent's\n    // _renderValidatedComponent) assume that calls to render aren't nested;\n    // verify that that's the case.\n    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : undefined;\n\n    var componentInstance = instantiateReactComponent(nextElement, null);\n    var reactRootID = ReactMount._registerComponent(componentInstance, container);\n\n    // The initial render is synchronous but any updates that happen during\n    // rendering, in componentWillMount or componentDidMount, will be batched\n    // according to the current batching strategy.\n\n    ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, reactRootID, container, shouldReuseMarkup, context);\n\n    if (process.env.NODE_ENV !== 'production') {\n      // Record the root element in case it later gets transplanted.\n      rootElementsByReactRootID[reactRootID] = getReactRootElementInContainer(container);\n    }\n\n    return componentInstance;\n  },\n\n  /**\n   * Renders a React component into the DOM in the supplied `container`.\n   *\n   * If the React component was previously rendered into `container`, this will\n   * perform an update on it and only mutate the DOM as necessary to reflect the\n   * latest React component.\n   *\n   * @param {ReactComponent} parentComponent The conceptual parent of this render tree.\n   * @param {ReactElement} nextElement Component element to render.\n   * @param {DOMElement} container DOM element to render into.\n   * @param {?function} callback function triggered on completion\n   * @return {ReactComponent} Component instance rendered in `container`.\n   */\n  renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {\n    !(parentComponent != null && parentComponent._reactInternalInstance != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'parentComponent must be a valid React Component') : invariant(false) : undefined;\n    return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);\n  },\n\n  _renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {\n    !ReactElement.isValidElement(nextElement) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOM.render(): Invalid component element.%s', typeof nextElement === 'string' ? ' Instead of passing an element string, make sure to instantiate ' + 'it by passing it to React.createElement.' : typeof nextElement === 'function' ? ' Instead of passing a component class, make sure to instantiate ' + 'it by passing it to React.createElement.' :\n    // Check if it quacks like an element\n    nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : invariant(false) : undefined;\n\n    process.env.NODE_ENV !== 'production' ? warning(!container || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : undefined;\n\n    var nextWrappedElement = new ReactElement(TopLevelWrapper, null, null, null, null, null, nextElement);\n\n    var prevComponent = instancesByReactRootID[getReactRootID(container)];\n\n    if (prevComponent) {\n      var prevWrappedElement = prevComponent._currentElement;\n      var prevElement = prevWrappedElement.props;\n      if (shouldUpdateReactComponent(prevElement, nextElement)) {\n        var publicInst = prevComponent._renderedComponent.getPublicInstance();\n        var updatedCallback = callback && function () {\n          callback.call(publicInst);\n        };\n        ReactMount._updateRootComponent(prevComponent, nextWrappedElement, container, updatedCallback);\n        return publicInst;\n      } else {\n        ReactMount.unmountComponentAtNode(container);\n      }\n    }\n\n    var reactRootElement = getReactRootElementInContainer(container);\n    var containerHasReactMarkup = reactRootElement && !!internalGetID(reactRootElement);\n    var containerHasNonRootReactChild = hasNonRootReactChild(container);\n\n    if (process.env.NODE_ENV !== 'production') {\n      process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.') : undefined;\n\n      if (!containerHasReactMarkup || reactRootElement.nextSibling) {\n        var rootElementSibling = reactRootElement;\n        while (rootElementSibling) {\n          if (internalGetID(rootElementSibling)) {\n            process.env.NODE_ENV !== 'production' ? warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.') : undefined;\n            break;\n          }\n          rootElementSibling = rootElementSibling.nextSibling;\n        }\n      }\n    }\n\n    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent && !containerHasNonRootReactChild;\n    var component = ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, parentComponent != null ? parentComponent._reactInternalInstance._processChildContext(parentComponent._reactInternalInstance._context) : emptyObject)._renderedComponent.getPublicInstance();\n    if (callback) {\n      callback.call(component);\n    }\n    return component;\n  },\n\n  /**\n   * Renders a React component into the DOM in the supplied `container`.\n   *\n   * If the React component was previously rendered into `container`, this will\n   * perform an update on it and only mutate the DOM as necessary to reflect the\n   * latest React component.\n   *\n   * @param {ReactElement} nextElement Component element to render.\n   * @param {DOMElement} container DOM element to render into.\n   * @param {?function} callback function triggered on completion\n   * @return {ReactComponent} Component instance rendered in `container`.\n   */\n  render: function (nextElement, container, callback) {\n    return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);\n  },\n\n  /**\n   * Registers a container node into which React components will be rendered.\n   * This also creates the \"reactRoot\" ID that will be assigned to the element\n   * rendered within.\n   *\n   * @param {DOMElement} container DOM element to register as a container.\n   * @return {string} The \"reactRoot\" ID of elements rendered within.\n   */\n  registerContainer: function (container) {\n    var reactRootID = getReactRootID(container);\n    if (reactRootID) {\n      // If one exists, make sure it is a valid \"reactRoot\" ID.\n      reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID);\n    }\n    if (!reactRootID) {\n      // No valid \"reactRoot\" ID found, create one.\n      reactRootID = ReactInstanceHandles.createReactRootID();\n    }\n    containersByReactRootID[reactRootID] = container;\n    return reactRootID;\n  },\n\n  /**\n   * Unmounts and destroys the React component rendered in the `container`.\n   *\n   * @param {DOMElement} container DOM element containing a React component.\n   * @return {boolean} True if a component was found in and unmounted from\n   *                   `container`\n   */\n  unmountComponentAtNode: function (container) {\n    // Various parts of our code (such as ReactCompositeComponent's\n    // _renderValidatedComponent) assume that calls to render aren't nested;\n    // verify that that's the case. (Strictly speaking, unmounting won't cause a\n    // render but we still don't expect to be in a render call here.)\n    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from render ' + 'is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : undefined;\n\n    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : invariant(false) : undefined;\n\n    var reactRootID = getReactRootID(container);\n    var component = instancesByReactRootID[reactRootID];\n    if (!component) {\n      // Check if the node being unmounted was rendered by React, but isn't a\n      // root node.\n      var containerHasNonRootReactChild = hasNonRootReactChild(container);\n\n      // Check if the container itself is a React root node.\n      var containerID = internalGetID(container);\n      var isContainerReactRoot = containerID && containerID === ReactInstanceHandles.getReactRootIDFromNodeID(containerID);\n\n      if (process.env.NODE_ENV !== 'production') {\n        process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'unmountComponentAtNode(): The node you\\'re attempting to unmount ' + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.') : undefined;\n      }\n\n      return false;\n    }\n    ReactUpdates.batchedUpdates(unmountComponentFromNode, component, container);\n    delete instancesByReactRootID[reactRootID];\n    delete containersByReactRootID[reactRootID];\n    if (process.env.NODE_ENV !== 'production') {\n      delete rootElementsByReactRootID[reactRootID];\n    }\n    return true;\n  },\n\n  /**\n   * Finds the container DOM element that contains React component to which the\n   * supplied DOM `id` belongs.\n   *\n   * @param {string} id The ID of an element rendered by a React component.\n   * @return {?DOMElement} DOM element that contains the `id`.\n   */\n  findReactContainerForID: function (id) {\n    var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(id);\n    var container = containersByReactRootID[reactRootID];\n\n    if (process.env.NODE_ENV !== 'production') {\n      var rootElement = rootElementsByReactRootID[reactRootID];\n      if (rootElement && rootElement.parentNode !== container) {\n        process.env.NODE_ENV !== 'production' ? warning(\n        // Call internalGetID here because getID calls isValid which calls\n        // findReactContainerForID (this function).\n        internalGetID(rootElement) === reactRootID, 'ReactMount: Root element ID differed from reactRootID.') : undefined;\n        var containerChild = container.firstChild;\n        if (containerChild && reactRootID === internalGetID(containerChild)) {\n          // If the container has a new child with the same ID as the old\n          // root element, then rootElementsByReactRootID[reactRootID] is\n          // just stale and needs to be updated. The case that deserves a\n          // warning is when the container is empty.\n          rootElementsByReactRootID[reactRootID] = containerChild;\n        } else {\n          process.env.NODE_ENV !== 'production' ? warning(false, 'ReactMount: Root element has been removed from its original ' + 'container. New container: %s', rootElement.parentNode) : undefined;\n        }\n      }\n    }\n\n    return container;\n  },\n\n  /**\n   * Finds an element rendered by React with the supplied ID.\n   *\n   * @param {string} id ID of a DOM node in the React component.\n   * @return {DOMElement} Root DOM node of the React component.\n   */\n  findReactNodeByID: function (id) {\n    var reactRoot = ReactMount.findReactContainerForID(id);\n    return ReactMount.findComponentRoot(reactRoot, id);\n  },\n\n  /**\n   * Traverses up the ancestors of the supplied node to find a node that is a\n   * DOM representation of a React component rendered by this copy of React.\n   *\n   * @param {*} node\n   * @return {?DOMEventTarget}\n   * @internal\n   */\n  getFirstReactDOM: function (node) {\n    return findFirstReactDOMImpl(node);\n  },\n\n  /**\n   * Finds a node with the supplied `targetID` inside of the supplied\n   * `ancestorNode`.  Exploits the ID naming scheme to perform the search\n   * quickly.\n   *\n   * @param {DOMEventTarget} ancestorNode Search from this root.\n   * @pararm {string} targetID ID of the DOM representation of the component.\n   * @return {DOMEventTarget} DOM node with the supplied `targetID`.\n   * @internal\n   */\n  findComponentRoot: function (ancestorNode, targetID) {\n    var firstChildren = findComponentRootReusableArray;\n    var childIndex = 0;\n\n    var deepestAncestor = findDeepestCachedAncestor(targetID) || ancestorNode;\n\n    if (process.env.NODE_ENV !== 'production') {\n      // This will throw on the next line; give an early warning\n      process.env.NODE_ENV !== 'production' ? warning(deepestAncestor != null, 'React can\\'t find the root component node for data-reactid value ' + '`%s`. If you\\'re seeing this message, it probably means that ' + 'you\\'ve loaded two copies of React on the page. At this time, only ' + 'a single copy of React can be loaded at a time.', targetID) : undefined;\n    }\n\n    firstChildren[0] = deepestAncestor.firstChild;\n    firstChildren.length = 1;\n\n    while (childIndex < firstChildren.length) {\n      var child = firstChildren[childIndex++];\n      var targetChild;\n\n      while (child) {\n        var childID = ReactMount.getID(child);\n        if (childID) {\n          // Even if we find the node we're looking for, we finish looping\n          // through its siblings to ensure they're cached so that we don't have\n          // to revisit this node again. Otherwise, we make n^2 calls to getID\n          // when visiting the many children of a single node in order.\n\n          if (targetID === childID) {\n            targetChild = child;\n          } else if (ReactInstanceHandles.isAncestorIDOf(childID, targetID)) {\n            // If we find a child whose ID is an ancestor of the given ID,\n            // then we can be sure that we only want to search the subtree\n            // rooted at this child, so we can throw out the rest of the\n            // search state.\n            firstChildren.length = childIndex = 0;\n            firstChildren.push(child.firstChild);\n          }\n        } else {\n          // If this child had no ID, then there's a chance that it was\n          // injected automatically by the browser, as when a `<table>`\n          // element sprouts an extra `<tbody>` child as a side effect of\n          // `.innerHTML` parsing. Optimistically continue down this\n          // branch, but not before examining the other siblings.\n          firstChildren.push(child.firstChild);\n        }\n\n        child = child.nextSibling;\n      }\n\n      if (targetChild) {\n        // Emptying firstChildren/findComponentRootReusableArray is\n        // not necessary for correctness, but it helps the GC reclaim\n        // any nodes that were left at the end of the search.\n        firstChildren.length = 0;\n\n        return targetChild;\n      }\n    }\n\n    firstChildren.length = 0;\n\n    !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'findComponentRoot(..., %s): Unable to find element. This probably ' + 'means the DOM was unexpectedly mutated (e.g., by the browser), ' + 'usually due to forgetting a <tbody> when using tables, nesting tags ' + 'like <form>, <p>, or <a>, or using non-SVG elements in an <svg> ' + 'parent. ' + 'Try inspecting the child nodes of the element with React ID `%s`.', targetID, ReactMount.getID(ancestorNode)) : invariant(false) : undefined;\n  },\n\n  _mountImageIntoNode: function (markup, container, shouldReuseMarkup, transaction) {\n    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mountComponentIntoNode(...): Target container is not valid.') : invariant(false) : undefined;\n\n    if (shouldReuseMarkup) {\n      var rootElement = getReactRootElementInContainer(container);\n      if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {\n        return;\n      } else {\n        var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);\n        rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);\n\n        var rootMarkup = rootElement.outerHTML;\n        rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);\n\n        var normalizedMarkup = markup;\n        if (process.env.NODE_ENV !== 'production') {\n          // because rootMarkup is retrieved from the DOM, various normalizations\n          // will have occurred which will not be present in `markup`. Here,\n          // insert markup into a <div> or <iframe> depending on the container\n          // type to perform the same normalizations before comparing.\n          var normalizer;\n          if (container.nodeType === ELEMENT_NODE_TYPE) {\n            normalizer = document.createElement('div');\n            normalizer.innerHTML = markup;\n            normalizedMarkup = normalizer.innerHTML;\n          } else {\n            normalizer = document.createElement('iframe');\n            document.body.appendChild(normalizer);\n            normalizer.contentDocument.write(markup);\n            normalizedMarkup = normalizer.contentDocument.documentElement.outerHTML;\n            document.body.removeChild(normalizer);\n          }\n        }\n\n        var diffIndex = firstDifferenceIndex(normalizedMarkup, rootMarkup);\n        var difference = ' (client) ' + normalizedMarkup.substring(diffIndex - 20, diffIndex + 20) + '\\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);\n\n        !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\\'re trying to render a component to the document using ' + 'server rendering but the checksum was invalid. This usually ' + 'means you rendered a different component type or props on ' + 'the client from the one on the server, or your render() ' + 'methods are impure. React cannot handle this case due to ' + 'cross-browser quirks by rendering at the document root. You ' + 'should look for environment dependent code in your components ' + 'and ensure the props are the same client and server side:\\n%s', difference) : invariant(false) : undefined;\n\n        if (process.env.NODE_ENV !== 'production') {\n          process.env.NODE_ENV !== 'production' ? warning(false, 'React attempted to reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server:\\n%s', difference) : undefined;\n        }\n      }\n    }\n\n    !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\\'re trying to render a component to the document but ' + 'you didn\\'t use server rendering. We can\\'t do this ' + 'without using server rendering due to cross-browser quirks. ' + 'See ReactDOMServer.renderToString() for server rendering.') : invariant(false) : undefined;\n\n    if (transaction.useCreateElement) {\n      while (container.lastChild) {\n        container.removeChild(container.lastChild);\n      }\n      container.appendChild(markup);\n    } else {\n      setInnerHTML(container, markup);\n    }\n  },\n\n  ownerDocumentContextKey: ownerDocumentContextKey,\n\n  /**\n   * React ID utilities.\n   */\n\n  getReactRootID: getReactRootID,\n\n  getID: getID,\n\n  setID: setID,\n\n  getNode: getNode,\n\n  getNodeFromInstance: getNodeFromInstance,\n\n  isValid: isValid,\n\n  purgeID: purgeID\n};\n\nReactPerf.measureMethods(ReactMount, 'ReactMount', {\n  _renderNewRootComponent: '_renderNewRootComponent',\n  _mountImageIntoNode: '_mountImageIntoNode'\n});\n\nmodule.exports = ReactMount;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}