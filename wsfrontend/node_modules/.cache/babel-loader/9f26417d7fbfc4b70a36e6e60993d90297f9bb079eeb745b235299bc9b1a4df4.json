{"ast":null,"code":"/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactDefaultPerfAnalysis\n */\n\n'use strict';\n\nvar assign = require('./Object.assign');\n\n// Don't try to save users less than 1.2ms (a number I made up)\nvar DONT_CARE_THRESHOLD = 1.2;\nvar DOM_OPERATION_TYPES = {\n  '_mountImageIntoNode': 'set innerHTML',\n  INSERT_MARKUP: 'set innerHTML',\n  MOVE_EXISTING: 'move',\n  REMOVE_NODE: 'remove',\n  SET_MARKUP: 'set innerHTML',\n  TEXT_CONTENT: 'set textContent',\n  'setValueForProperty': 'update attribute',\n  'setValueForAttribute': 'update attribute',\n  'deleteValueForProperty': 'remove attribute',\n  'setValueForStyles': 'update styles',\n  'replaceNodeWithMarkup': 'replace',\n  'updateTextContent': 'set textContent'\n};\nfunction getTotalTime(measurements) {\n  // TODO: return number of DOM ops? could be misleading.\n  // TODO: measure dropped frames after reconcile?\n  // TODO: log total time of each reconcile and the top-level component\n  // class that triggered it.\n  var totalTime = 0;\n  for (var i = 0; i < measurements.length; i++) {\n    var measurement = measurements[i];\n    totalTime += measurement.totalTime;\n  }\n  return totalTime;\n}\nfunction getDOMSummary(measurements) {\n  var items = [];\n  measurements.forEach(function (measurement) {\n    Object.keys(measurement.writes).forEach(function (id) {\n      measurement.writes[id].forEach(function (write) {\n        items.push({\n          id: id,\n          type: DOM_OPERATION_TYPES[write.type] || write.type,\n          args: write.args\n        });\n      });\n    });\n  });\n  return items;\n}\nfunction getExclusiveSummary(measurements) {\n  var candidates = {};\n  var displayName;\n  for (var i = 0; i < measurements.length; i++) {\n    var measurement = measurements[i];\n    var allIDs = assign({}, measurement.exclusive, measurement.inclusive);\n    for (var id in allIDs) {\n      displayName = measurement.displayNames[id].current;\n      candidates[displayName] = candidates[displayName] || {\n        componentName: displayName,\n        inclusive: 0,\n        exclusive: 0,\n        render: 0,\n        count: 0\n      };\n      if (measurement.render[id]) {\n        candidates[displayName].render += measurement.render[id];\n      }\n      if (measurement.exclusive[id]) {\n        candidates[displayName].exclusive += measurement.exclusive[id];\n      }\n      if (measurement.inclusive[id]) {\n        candidates[displayName].inclusive += measurement.inclusive[id];\n      }\n      if (measurement.counts[id]) {\n        candidates[displayName].count += measurement.counts[id];\n      }\n    }\n  }\n\n  // Now make a sorted array with the results.\n  var arr = [];\n  for (displayName in candidates) {\n    if (candidates[displayName].exclusive >= DONT_CARE_THRESHOLD) {\n      arr.push(candidates[displayName]);\n    }\n  }\n  arr.sort(function (a, b) {\n    return b.exclusive - a.exclusive;\n  });\n  return arr;\n}\nfunction getInclusiveSummary(measurements, onlyClean) {\n  var candidates = {};\n  var inclusiveKey;\n  for (var i = 0; i < measurements.length; i++) {\n    var measurement = measurements[i];\n    var allIDs = assign({}, measurement.exclusive, measurement.inclusive);\n    var cleanComponents;\n    if (onlyClean) {\n      cleanComponents = getUnchangedComponents(measurement);\n    }\n    for (var id in allIDs) {\n      if (onlyClean && !cleanComponents[id]) {\n        continue;\n      }\n      var displayName = measurement.displayNames[id];\n\n      // Inclusive time is not useful for many components without knowing where\n      // they are instantiated. So we aggregate inclusive time with both the\n      // owner and current displayName as the key.\n      inclusiveKey = displayName.owner + ' > ' + displayName.current;\n      candidates[inclusiveKey] = candidates[inclusiveKey] || {\n        componentName: inclusiveKey,\n        time: 0,\n        count: 0\n      };\n      if (measurement.inclusive[id]) {\n        candidates[inclusiveKey].time += measurement.inclusive[id];\n      }\n      if (measurement.counts[id]) {\n        candidates[inclusiveKey].count += measurement.counts[id];\n      }\n    }\n  }\n\n  // Now make a sorted array with the results.\n  var arr = [];\n  for (inclusiveKey in candidates) {\n    if (candidates[inclusiveKey].time >= DONT_CARE_THRESHOLD) {\n      arr.push(candidates[inclusiveKey]);\n    }\n  }\n  arr.sort(function (a, b) {\n    return b.time - a.time;\n  });\n  return arr;\n}\nfunction getUnchangedComponents(measurement) {\n  // For a given reconcile, look at which components did not actually\n  // render anything to the DOM and return a mapping of their ID to\n  // the amount of time it took to render the entire subtree.\n  var cleanComponents = {};\n  var dirtyLeafIDs = Object.keys(measurement.writes);\n  var allIDs = assign({}, measurement.exclusive, measurement.inclusive);\n  for (var id in allIDs) {\n    var isDirty = false;\n    // For each component that rendered, see if a component that triggered\n    // a DOM op is in its subtree.\n    for (var i = 0; i < dirtyLeafIDs.length; i++) {\n      if (dirtyLeafIDs[i].indexOf(id) === 0) {\n        isDirty = true;\n        break;\n      }\n    }\n    // check if component newly created\n    if (measurement.created[id]) {\n      isDirty = true;\n    }\n    if (!isDirty && measurement.counts[id] > 0) {\n      cleanComponents[id] = true;\n    }\n  }\n  return cleanComponents;\n}\nvar ReactDefaultPerfAnalysis = {\n  getExclusiveSummary: getExclusiveSummary,\n  getInclusiveSummary: getInclusiveSummary,\n  getDOMSummary: getDOMSummary,\n  getTotalTime: getTotalTime\n};\nmodule.exports = ReactDefaultPerfAnalysis;","map":{"version":3,"names":["assign","require","DONT_CARE_THRESHOLD","DOM_OPERATION_TYPES","INSERT_MARKUP","MOVE_EXISTING","REMOVE_NODE","SET_MARKUP","TEXT_CONTENT","getTotalTime","measurements","totalTime","i","length","measurement","getDOMSummary","items","forEach","Object","keys","writes","id","write","push","type","args","getExclusiveSummary","candidates","displayName","allIDs","exclusive","inclusive","displayNames","current","componentName","render","count","counts","arr","sort","a","b","getInclusiveSummary","onlyClean","inclusiveKey","cleanComponents","getUnchangedComponents","owner","time","dirtyLeafIDs","isDirty","indexOf","created","ReactDefaultPerfAnalysis","module","exports"],"sources":["C:/Users/Ferhat/ws-project/wsfrontend/node_modules/react-emoji-picker/node_modules/react/lib/ReactDefaultPerfAnalysis.js"],"sourcesContent":["/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactDefaultPerfAnalysis\n */\n\n'use strict';\n\nvar assign = require('./Object.assign');\n\n// Don't try to save users less than 1.2ms (a number I made up)\nvar DONT_CARE_THRESHOLD = 1.2;\nvar DOM_OPERATION_TYPES = {\n  '_mountImageIntoNode': 'set innerHTML',\n  INSERT_MARKUP: 'set innerHTML',\n  MOVE_EXISTING: 'move',\n  REMOVE_NODE: 'remove',\n  SET_MARKUP: 'set innerHTML',\n  TEXT_CONTENT: 'set textContent',\n  'setValueForProperty': 'update attribute',\n  'setValueForAttribute': 'update attribute',\n  'deleteValueForProperty': 'remove attribute',\n  'setValueForStyles': 'update styles',\n  'replaceNodeWithMarkup': 'replace',\n  'updateTextContent': 'set textContent'\n};\n\nfunction getTotalTime(measurements) {\n  // TODO: return number of DOM ops? could be misleading.\n  // TODO: measure dropped frames after reconcile?\n  // TODO: log total time of each reconcile and the top-level component\n  // class that triggered it.\n  var totalTime = 0;\n  for (var i = 0; i < measurements.length; i++) {\n    var measurement = measurements[i];\n    totalTime += measurement.totalTime;\n  }\n  return totalTime;\n}\n\nfunction getDOMSummary(measurements) {\n  var items = [];\n  measurements.forEach(function (measurement) {\n    Object.keys(measurement.writes).forEach(function (id) {\n      measurement.writes[id].forEach(function (write) {\n        items.push({\n          id: id,\n          type: DOM_OPERATION_TYPES[write.type] || write.type,\n          args: write.args\n        });\n      });\n    });\n  });\n  return items;\n}\n\nfunction getExclusiveSummary(measurements) {\n  var candidates = {};\n  var displayName;\n\n  for (var i = 0; i < measurements.length; i++) {\n    var measurement = measurements[i];\n    var allIDs = assign({}, measurement.exclusive, measurement.inclusive);\n\n    for (var id in allIDs) {\n      displayName = measurement.displayNames[id].current;\n\n      candidates[displayName] = candidates[displayName] || {\n        componentName: displayName,\n        inclusive: 0,\n        exclusive: 0,\n        render: 0,\n        count: 0\n      };\n      if (measurement.render[id]) {\n        candidates[displayName].render += measurement.render[id];\n      }\n      if (measurement.exclusive[id]) {\n        candidates[displayName].exclusive += measurement.exclusive[id];\n      }\n      if (measurement.inclusive[id]) {\n        candidates[displayName].inclusive += measurement.inclusive[id];\n      }\n      if (measurement.counts[id]) {\n        candidates[displayName].count += measurement.counts[id];\n      }\n    }\n  }\n\n  // Now make a sorted array with the results.\n  var arr = [];\n  for (displayName in candidates) {\n    if (candidates[displayName].exclusive >= DONT_CARE_THRESHOLD) {\n      arr.push(candidates[displayName]);\n    }\n  }\n\n  arr.sort(function (a, b) {\n    return b.exclusive - a.exclusive;\n  });\n\n  return arr;\n}\n\nfunction getInclusiveSummary(measurements, onlyClean) {\n  var candidates = {};\n  var inclusiveKey;\n\n  for (var i = 0; i < measurements.length; i++) {\n    var measurement = measurements[i];\n    var allIDs = assign({}, measurement.exclusive, measurement.inclusive);\n    var cleanComponents;\n\n    if (onlyClean) {\n      cleanComponents = getUnchangedComponents(measurement);\n    }\n\n    for (var id in allIDs) {\n      if (onlyClean && !cleanComponents[id]) {\n        continue;\n      }\n\n      var displayName = measurement.displayNames[id];\n\n      // Inclusive time is not useful for many components without knowing where\n      // they are instantiated. So we aggregate inclusive time with both the\n      // owner and current displayName as the key.\n      inclusiveKey = displayName.owner + ' > ' + displayName.current;\n\n      candidates[inclusiveKey] = candidates[inclusiveKey] || {\n        componentName: inclusiveKey,\n        time: 0,\n        count: 0\n      };\n\n      if (measurement.inclusive[id]) {\n        candidates[inclusiveKey].time += measurement.inclusive[id];\n      }\n      if (measurement.counts[id]) {\n        candidates[inclusiveKey].count += measurement.counts[id];\n      }\n    }\n  }\n\n  // Now make a sorted array with the results.\n  var arr = [];\n  for (inclusiveKey in candidates) {\n    if (candidates[inclusiveKey].time >= DONT_CARE_THRESHOLD) {\n      arr.push(candidates[inclusiveKey]);\n    }\n  }\n\n  arr.sort(function (a, b) {\n    return b.time - a.time;\n  });\n\n  return arr;\n}\n\nfunction getUnchangedComponents(measurement) {\n  // For a given reconcile, look at which components did not actually\n  // render anything to the DOM and return a mapping of their ID to\n  // the amount of time it took to render the entire subtree.\n  var cleanComponents = {};\n  var dirtyLeafIDs = Object.keys(measurement.writes);\n  var allIDs = assign({}, measurement.exclusive, measurement.inclusive);\n\n  for (var id in allIDs) {\n    var isDirty = false;\n    // For each component that rendered, see if a component that triggered\n    // a DOM op is in its subtree.\n    for (var i = 0; i < dirtyLeafIDs.length; i++) {\n      if (dirtyLeafIDs[i].indexOf(id) === 0) {\n        isDirty = true;\n        break;\n      }\n    }\n    // check if component newly created\n    if (measurement.created[id]) {\n      isDirty = true;\n    }\n    if (!isDirty && measurement.counts[id] > 0) {\n      cleanComponents[id] = true;\n    }\n  }\n  return cleanComponents;\n}\n\nvar ReactDefaultPerfAnalysis = {\n  getExclusiveSummary: getExclusiveSummary,\n  getInclusiveSummary: getInclusiveSummary,\n  getDOMSummary: getDOMSummary,\n  getTotalTime: getTotalTime\n};\n\nmodule.exports = ReactDefaultPerfAnalysis;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}